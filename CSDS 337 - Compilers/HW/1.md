# HW 1

## Syntax

### Grammars

For each of the following three grammars:

1. Briefly describe the language defined by the grammar.
2. State whether the language is ambiguous, and if so, submit a single string and two corresponding parse trees.

#### 1

$S\to0~S~1~|~0~1$

> [!answer]
> This essentially means that $S$ can be $01$, or $0$ followed by any $S$ followed by $1$.
> 
> This practically means that $S$ is any $n$ amount of $0$s followed by $n$ amount of $1$s.
> 
> This language is not ambiguous. All pairs must be parsed from outside in, there are no other ways to parse this tree, or inner $S$'s will fail to parse.

#### 2

$S\to a~S~b~S~|~b~S~a~S~|~\epsilon$

> [!answer]
> This means that $S$ can be nothing, or specific combinations of $a$ and $b$ such that there is an equal amount of $a$'s and $b$'s.
> 
> This language is ambiguous.
> $abab$ for example may be parsed $(a\epsilon b(a\epsilon b\epsilon ))$ or $(a(b\epsilon a\epsilon )b\epsilon )$
> Where $()$ represent a recursive node in the parse tree.

#### 3

$S\to S+S~|~S*S~|~(S)~|~\text{id}$

> [!answer]
> This is basic arithmetic syntax for the $+$ and $*$ operators. It matches any expression containing $+$, $*$, balanced pairs of parenthesis $()$, and numbers.
> 
> This grammar is ambiguous because there is no order of operations.
> $1+2*3$ could be parsed as $\langle\langle1+2\rangle*3\rangle$ or as $\langle1+\langle 2*3\rangle\rangle$
> Where $\langle\rangle$ represent a recursive node in the parse tree.

### Syntax-Directed Translation

Construct a syntax-directed translation scheme that translates arithmetic expressions from infix notation to prefix notation in which an operator appears before its operands; e.g., $-xy$ is the prefix notation for $x-y$. Give annotated parse trees for the inputs $9-5+2$ and $9-5*2$.

> [!answer]
> ![[1/tables#^4|tables]]
> ![[1/tables#^4a|tables]]
> ![[1/tables#^4b|tables]]

## Static Scope

### Static Scope

For the block-structured C code, indicate the values assigned to $w$, $x$, $y$, and $z$.

#### a

```C
int w, x, y, z;
int i = 4; int j = 5;
{
	int j = 7;
	i = 6;
	w = i + j;
}
x = i + j;
{
	int i = 8;
	y = i + j;
}
z = i + j;
```

> [!answer]
> ![[1/tables#^1|tables]]
> 
> $w,x,y,z=13, 11, 13, 11$

#### b

```C
int w, x, y, z;
int i = 3; int j = 4;
{
	int i = 5;
	w = i + j;
}
x = i + j;
{
	int j = 6;
	i = 7;
	y = i + j;
}
z = i + j;
```

> [!answer]
> ![[1/tables#^1|tables]]
> 
> $w,x,y,z=9, 7, 13, 11$

### Symbol Table

Implement a hierarchal environment implemented as a *chained symbol table* (Figure 2.36 and 2.37). The table key is a string representing an $\text{id}$, and the value is unused for the time being. Create a function to print the contents of a chained symbol table.

> [!answer]
> ![[1/tables#^3|tables]]
