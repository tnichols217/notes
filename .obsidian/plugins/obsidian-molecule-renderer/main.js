/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/smiles-drawer/src/MathHelper.js
var require_MathHelper = __commonJS({
  "node_modules/smiles-drawer/src/MathHelper.js"(exports, module2) {
    var MathHelper2 = class {
      static round(value, decimals) {
        decimals = decimals ? decimals : 1;
        return Number(Math.round(value + "e" + decimals) + "e-" + decimals);
      }
      static meanAngle(arr) {
        let sin = 0;
        let cos = 0;
        for (var i = 0; i < arr.length; i++) {
          sin += Math.sin(arr[i]);
          cos += Math.cos(arr[i]);
        }
        return Math.atan2(sin / arr.length, cos / arr.length);
      }
      static innerAngle(n) {
        return MathHelper2.toRad((n - 2) * 180 / n);
      }
      static polyCircumradius(s, n) {
        return s / (2 * Math.sin(Math.PI / n));
      }
      static apothem(r, n) {
        return r * Math.cos(Math.PI / n);
      }
      static apothemFromSideLength(s, n) {
        let r = MathHelper2.polyCircumradius(s, n);
        return MathHelper2.apothem(r, n);
      }
      static centralAngle(n) {
        return MathHelper2.toRad(360 / n);
      }
      static toDeg(rad) {
        return rad * MathHelper2.degFactor;
      }
      static toRad(deg) {
        return deg * MathHelper2.radFactor;
      }
      static parityOfPermutation(arr) {
        let visited = new Uint8Array(arr.length);
        let evenLengthCycleCount = 0;
        let traverseCycle = function(i2, cycleLength = 0) {
          if (visited[i2] === 1) {
            return cycleLength;
          }
          cycleLength++;
          visited[i2] = 1;
          return traverseCycle(arr[i2], cycleLength);
        };
        for (var i = 0; i < arr.length; i++) {
          if (visited[i] === 1) {
            continue;
          }
          let cycleLength = traverseCycle(i);
          evenLengthCycleCount += 1 - cycleLength % 2;
        }
        return evenLengthCycleCount % 2 ? -1 : 1;
      }
      static get radFactor() {
        return Math.PI / 180;
      }
      static get degFactor() {
        return 180 / Math.PI;
      }
      static get twoPI() {
        return 2 * Math.PI;
      }
    };
    module2.exports = MathHelper2;
  }
});

// node_modules/smiles-drawer/src/ArrayHelper.js
var require_ArrayHelper = __commonJS({
  "node_modules/smiles-drawer/src/ArrayHelper.js"(exports, module2) {
    var ArrayHelper = class {
      static clone(arr) {
        let out = Array.isArray(arr) ? Array() : {};
        for (let key in arr) {
          let value = arr[key];
          if (typeof value.clone === "function") {
            out[key] = value.clone();
          } else {
            out[key] = typeof value === "object" ? ArrayHelper.clone(value) : value;
          }
        }
        return out;
      }
      static equals(arrA, arrB) {
        if (arrA.length !== arrB.length) {
          return false;
        }
        let tmpA = arrA.slice().sort();
        let tmpB = arrB.slice().sort();
        for (var i = 0; i < tmpA.length; i++) {
          if (tmpA[i] !== tmpB[i]) {
            return false;
          }
        }
        return true;
      }
      static print(arr) {
        if (arr.length == 0) {
          return "";
        }
        let s = "(";
        for (let i = 0; i < arr.length; i++) {
          s += arr[i].id ? arr[i].id + ", " : arr[i] + ", ";
        }
        s = s.substring(0, s.length - 2);
        return s + ")";
      }
      static each(arr, callback) {
        for (let i = 0; i < arr.length; i++) {
          callback(arr[i]);
        }
      }
      static get(arr, property, value) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i][property] == value) {
            return arr[i];
          }
        }
      }
      static contains(arr, options) {
        if (!options.property && !options.func) {
          for (let i = 0; i < arr.length; i++) {
            if (arr[i] == options.value) {
              return true;
            }
          }
        } else if (options.func) {
          for (let i = 0; i < arr.length; i++) {
            if (options.func(arr[i])) {
              return true;
            }
          }
        } else {
          for (let i = 0; i < arr.length; i++) {
            if (arr[i][options.property] == options.value) {
              return true;
            }
          }
        }
        return false;
      }
      static intersection(arrA, arrB) {
        let intersection = new Array();
        for (let i = 0; i < arrA.length; i++) {
          for (let j = 0; j < arrB.length; j++) {
            if (arrA[i] === arrB[j]) {
              intersection.push(arrA[i]);
            }
          }
        }
        return intersection;
      }
      static unique(arr) {
        let contains = {};
        return arr.filter(function(i) {
          return contains[i] !== void 0 ? false : contains[i] = true;
        });
      }
      static count(arr, value) {
        let count = 0;
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] === value) {
            count++;
          }
        }
        return count;
      }
      static toggle(arr, value) {
        let newArr = Array();
        let removed = false;
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== value) {
            newArr.push(arr[i]);
          } else {
            removed = true;
          }
        }
        if (!removed) {
          newArr.push(value);
        }
        return newArr;
      }
      static remove(arr, value) {
        let tmp = Array();
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== value) {
            tmp.push(arr[i]);
          }
        }
        return tmp;
      }
      static removeUnique(arr, value) {
        let index = arr.indexOf(value);
        if (index > -1) {
          arr.splice(index, 1);
        }
        return arr;
      }
      static removeAll(arrA, arrB) {
        return arrA.filter(function(item) {
          return arrB.indexOf(item) === -1;
        });
      }
      static merge(arrA, arrB) {
        let arr = new Array(arrA.length + arrB.length);
        for (let i = 0; i < arrA.length; i++) {
          arr[i] = arrA[i];
        }
        for (let i = 0; i < arrB.length; i++) {
          arr[arrA.length + i] = arrB[i];
        }
        return arr;
      }
      static containsAll(arrA, arrB) {
        let containing = 0;
        for (let i = 0; i < arrA.length; i++) {
          for (let j = 0; j < arrB.length; j++) {
            if (arrA[i] === arrB[j]) {
              containing++;
            }
          }
        }
        return containing === arrB.length;
      }
      static sortByAtomicNumberDesc(arr) {
        let map = arr.map(function(e, i) {
          return { index: i, value: e.atomicNumber.split(".").map(Number) };
        });
        map.sort(function(a, b) {
          let min = Math.min(b.value.length, a.value.length);
          let i = 0;
          while (i < min && b.value[i] === a.value[i]) {
            i++;
          }
          return i === min ? b.value.length - a.value.length : b.value[i] - a.value[i];
        });
        return map.map(function(e) {
          return arr[e.index];
        });
      }
      static deepCopy(arr) {
        let newArr = Array();
        for (let i = 0; i < arr.length; i++) {
          let item = arr[i];
          if (item instanceof Array) {
            newArr[i] = ArrayHelper.deepCopy(item);
          } else {
            newArr[i] = item;
          }
        }
        return newArr;
      }
    };
    module2.exports = ArrayHelper;
  }
});

// node_modules/smiles-drawer/src/Vector2.js
var require_Vector2 = __commonJS({
  "node_modules/smiles-drawer/src/Vector2.js"(exports, module2) {
    var Vector2 = class {
      constructor(x, y) {
        if (arguments.length == 0) {
          this.x = 0;
          this.y = 0;
        } else if (arguments.length == 1) {
          this.x = x.x;
          this.y = x.y;
        } else {
          this.x = x;
          this.y = y;
        }
      }
      clone() {
        return new Vector2(this.x, this.y);
      }
      toString() {
        return "(" + this.x + "," + this.y + ")";
      }
      add(vec) {
        this.x += vec.x;
        this.y += vec.y;
        return this;
      }
      subtract(vec) {
        this.x -= vec.x;
        this.y -= vec.y;
        return this;
      }
      divide(scalar) {
        this.x /= scalar;
        this.y /= scalar;
        return this;
      }
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      invert() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      angle() {
        return Math.atan2(this.y, this.x);
      }
      distance(vec) {
        return Math.sqrt((vec.x - this.x) * (vec.x - this.x) + (vec.y - this.y) * (vec.y - this.y));
      }
      distanceSq(vec) {
        return (vec.x - this.x) * (vec.x - this.x) + (vec.y - this.y) * (vec.y - this.y);
      }
      clockwise(vec) {
        let a = this.y * vec.x;
        let b = this.x * vec.y;
        if (a > b) {
          return -1;
        } else if (a === b) {
          return 0;
        }
        return 1;
      }
      relativeClockwise(center, vec) {
        let a = (this.y - center.y) * (vec.x - center.x);
        let b = (this.x - center.x) * (vec.y - center.y);
        if (a > b) {
          return -1;
        } else if (a === b) {
          return 0;
        }
        return 1;
      }
      rotate(angle) {
        let tmp = new Vector2(0, 0);
        let cosAngle = Math.cos(angle);
        let sinAngle = Math.sin(angle);
        tmp.x = this.x * cosAngle - this.y * sinAngle;
        tmp.y = this.x * sinAngle + this.y * cosAngle;
        this.x = tmp.x;
        this.y = tmp.y;
        return this;
      }
      rotateAround(angle, vec) {
        let s = Math.sin(angle);
        let c = Math.cos(angle);
        this.x -= vec.x;
        this.y -= vec.y;
        let x = this.x * c - this.y * s;
        let y = this.x * s + this.y * c;
        this.x = x + vec.x;
        this.y = y + vec.y;
        return this;
      }
      rotateTo(vec, center, offsetAngle = 0) {
        this.x += 1e-3;
        this.y -= 1e-3;
        let a = Vector2.subtract(this, center);
        let b = Vector2.subtract(vec, center);
        let angle = Vector2.angle(b, a);
        this.rotateAround(angle + offsetAngle, center);
        return this;
      }
      rotateAwayFrom(vec, center, angle) {
        this.rotateAround(angle, center);
        let distSqA = this.distanceSq(vec);
        this.rotateAround(-2 * angle, center);
        let distSqB = this.distanceSq(vec);
        if (distSqB < distSqA) {
          this.rotateAround(2 * angle, center);
        }
      }
      getRotateAwayFromAngle(vec, center, angle) {
        let tmp = this.clone();
        tmp.rotateAround(angle, center);
        let distSqA = tmp.distanceSq(vec);
        tmp.rotateAround(-2 * angle, center);
        let distSqB = tmp.distanceSq(vec);
        if (distSqB < distSqA) {
          return angle;
        } else {
          return -angle;
        }
      }
      getRotateTowardsAngle(vec, center, angle) {
        let tmp = this.clone();
        tmp.rotateAround(angle, center);
        let distSqA = tmp.distanceSq(vec);
        tmp.rotateAround(-2 * angle, center);
        let distSqB = tmp.distanceSq(vec);
        if (distSqB > distSqA) {
          return angle;
        } else {
          return -angle;
        }
      }
      getRotateToAngle(vec, center) {
        let a = Vector2.subtract(this, center);
        let b = Vector2.subtract(vec, center);
        let angle = Vector2.angle(b, a);
        return Number.isNaN(angle) ? 0 : angle;
      }
      isInPolygon(polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          if (polygon[i].y > this.y != polygon[j].y > this.y && this.x < (polygon[j].x - polygon[i].x) * (this.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x) {
            inside = !inside;
          }
        }
        return inside;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      normalize() {
        this.divide(this.length());
        return this;
      }
      normalized() {
        return Vector2.divideScalar(this, this.length());
      }
      whichSide(vecA, vecB) {
        return (this.x - vecA.x) * (vecB.y - vecA.y) - (this.y - vecA.y) * (vecB.x - vecA.x);
      }
      sameSideAs(vecA, vecB, vecC) {
        let d = this.whichSide(vecA, vecB);
        let dRef = vecC.whichSide(vecA, vecB);
        return d < 0 && dRef < 0 || d == 0 && dRef == 0 || d > 0 && dRef > 0;
      }
      static add(vecA, vecB) {
        return new Vector2(vecA.x + vecB.x, vecA.y + vecB.y);
      }
      static subtract(vecA, vecB) {
        return new Vector2(vecA.x - vecB.x, vecA.y - vecB.y);
      }
      static multiply(vecA, vecB) {
        return new Vector2(vecA.x * vecB.x, vecA.y * vecB.y);
      }
      static multiplyScalar(vec, scalar) {
        return new Vector2(vec.x, vec.y).multiplyScalar(scalar);
      }
      static midpoint(vecA, vecB) {
        return new Vector2((vecA.x + vecB.x) / 2, (vecA.y + vecB.y) / 2);
      }
      static normals(vecA, vecB) {
        let delta = Vector2.subtract(vecB, vecA);
        return [
          new Vector2(-delta.y, delta.x),
          new Vector2(delta.y, -delta.x)
        ];
      }
      static units(vecA, vecB) {
        let delta = Vector2.subtract(vecB, vecA);
        return [
          new Vector2(-delta.y, delta.x).normalize(),
          new Vector2(delta.y, -delta.x).normalize()
        ];
      }
      static divide(vecA, vecB) {
        return new Vector2(vecA.x / vecB.x, vecA.y / vecB.y);
      }
      static divideScalar(vecA, s) {
        return new Vector2(vecA.x / s, vecA.y / s);
      }
      static dot(vecA, vecB) {
        return vecA.x * vecB.x + vecA.y * vecB.y;
      }
      static angle(vecA, vecB) {
        let dot = Vector2.dot(vecA, vecB);
        return Math.acos(dot / (vecA.length() * vecB.length()));
      }
      static threePointangle(vecA, vecB, vecC) {
        let ab = Vector2.subtract(vecB, vecA);
        let bc = Vector2.subtract(vecC, vecB);
        let abLength = vecA.distance(vecB);
        let bcLength = vecB.distance(vecC);
        return Math.acos(Vector2.dot(ab, bc) / (abLength * bcLength));
      }
      static scalarProjection(vecA, vecB) {
        let unit = vecB.normalized();
        return Vector2.dot(vecA, unit);
      }
      static averageDirection(vecs) {
        let avg = new Vector2(0, 0);
        for (var i = 0; i < vecs.length; i++) {
          let vec = vecs[i];
          avg.add(vec);
        }
        return avg.normalize();
      }
    };
    module2.exports = Vector2;
  }
});

// node_modules/smiles-drawer/src/Line.js
var require_Line = __commonJS({
  "node_modules/smiles-drawer/src/Line.js"(exports, module2) {
    var Vector2 = require_Vector2();
    var Line = class {
      constructor(from = new Vector2(0, 0), to = new Vector2(0, 0), elementFrom = null, elementTo = null, chiralFrom = false, chiralTo = false) {
        this.from = from;
        this.to = to;
        this.elementFrom = elementFrom;
        this.elementTo = elementTo;
        this.chiralFrom = chiralFrom;
        this.chiralTo = chiralTo;
      }
      clone() {
        return new Line(this.from.clone(), this.to.clone(), this.elementFrom, this.elementTo);
      }
      getLength() {
        return Math.sqrt(Math.pow(this.to.x - this.from.x, 2) + Math.pow(this.to.y - this.from.y, 2));
      }
      getAngle() {
        let diff = Vector2.subtract(this.getRightVector(), this.getLeftVector());
        return diff.angle();
      }
      getRightVector() {
        if (this.from.x < this.to.x) {
          return this.to;
        } else {
          return this.from;
        }
      }
      getLeftVector() {
        if (this.from.x < this.to.x) {
          return this.from;
        } else {
          return this.to;
        }
      }
      getRightElement() {
        if (this.from.x < this.to.x) {
          return this.elementTo;
        } else {
          return this.elementFrom;
        }
      }
      getLeftElement() {
        if (this.from.x < this.to.x) {
          return this.elementFrom;
        } else {
          return this.elementTo;
        }
      }
      getRightChiral() {
        if (this.from.x < this.to.x) {
          return this.chiralTo;
        } else {
          return this.chiralFrom;
        }
      }
      getLeftChiral() {
        if (this.from.x < this.to.x) {
          return this.chiralFrom;
        } else {
          return this.chiralTo;
        }
      }
      setRightVector(x, y) {
        if (this.from.x < this.to.x) {
          this.to.x = x;
          this.to.y = y;
        } else {
          this.from.x = x;
          this.from.y = y;
        }
        return this;
      }
      setLeftVector(x, y) {
        if (this.from.x < this.to.x) {
          this.from.x = x;
          this.from.y = y;
        } else {
          this.to.x = x;
          this.to.y = y;
        }
        return this;
      }
      rotateToXAxis() {
        let left = this.getLeftVector();
        this.setRightVector(left.x + this.getLength(), left.y);
        return this;
      }
      rotate(theta) {
        let l = this.getLeftVector();
        let r = this.getRightVector();
        let sinTheta = Math.sin(theta);
        let cosTheta = Math.cos(theta);
        let x = cosTheta * (r.x - l.x) - sinTheta * (r.y - l.y) + l.x;
        let y = sinTheta * (r.x - l.x) - cosTheta * (r.y - l.y) + l.y;
        this.setRightVector(x, y);
        return this;
      }
      shortenFrom(by) {
        let f = Vector2.subtract(this.to, this.from);
        f.normalize();
        f.multiplyScalar(by);
        this.from.add(f);
        return this;
      }
      shortenTo(by) {
        let f = Vector2.subtract(this.from, this.to);
        f.normalize();
        f.multiplyScalar(by);
        this.to.add(f);
        return this;
      }
      shortenRight(by) {
        if (this.from.x < this.to.x) {
          this.shortenTo(by);
        } else {
          this.shortenFrom(by);
        }
        return this;
      }
      shortenLeft(by) {
        if (this.from.x < this.to.x) {
          this.shortenFrom(by);
        } else {
          this.shortenTo(by);
        }
        return this;
      }
      shorten(by) {
        let f = Vector2.subtract(this.from, this.to);
        f.normalize();
        f.multiplyScalar(by / 2);
        this.to.add(f);
        this.from.subtract(f);
        return this;
      }
    };
    module2.exports = Line;
  }
});

// node_modules/smiles-drawer/src/RingConnection.js
var require_RingConnection = __commonJS({
  "node_modules/smiles-drawer/src/RingConnection.js"(exports, module2) {
    var Vertex = require_Vertex();
    var Ring = require_Ring();
    var RingConnection = class {
      constructor(firstRing, secondRing) {
        this.id = null;
        this.firstRingId = firstRing.id;
        this.secondRingId = secondRing.id;
        this.vertices = new Set();
        for (var m = 0; m < firstRing.members.length; m++) {
          let c = firstRing.members[m];
          for (let n = 0; n < secondRing.members.length; n++) {
            let d = secondRing.members[n];
            if (c === d) {
              this.addVertex(c);
            }
          }
        }
      }
      addVertex(vertexId) {
        this.vertices.add(vertexId);
      }
      updateOther(ringId, otherRingId) {
        if (this.firstRingId === otherRingId) {
          this.secondRingId = ringId;
        } else {
          this.firstRingId = ringId;
        }
      }
      containsRing(ringId) {
        return this.firstRingId === ringId || this.secondRingId === ringId;
      }
      isBridge(vertices) {
        if (this.vertices.size > 2) {
          return true;
        }
        for (let vertexId of this.vertices) {
          if (vertices[vertexId].value.rings.length > 2) {
            return true;
          }
        }
        return false;
      }
      static isBridge(ringConnections, vertices, firstRingId, secondRingId) {
        let ringConnection = null;
        for (let i = 0; i < ringConnections.length; i++) {
          ringConnection = ringConnections[i];
          if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {
            return ringConnection.isBridge(vertices);
          }
        }
        return false;
      }
      static getNeighbours(ringConnections, ringId) {
        let neighbours = [];
        for (let i = 0; i < ringConnections.length; i++) {
          let ringConnection = ringConnections[i];
          if (ringConnection.firstRingId === ringId) {
            neighbours.push(ringConnection.secondRingId);
          } else if (ringConnection.secondRingId === ringId) {
            neighbours.push(ringConnection.firstRingId);
          }
        }
        return neighbours;
      }
      static getVertices(ringConnections, firstRingId, secondRingId) {
        for (let i = 0; i < ringConnections.length; i++) {
          let ringConnection = ringConnections[i];
          if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {
            return [...ringConnection.vertices];
          }
        }
      }
    };
    module2.exports = RingConnection;
  }
});

// node_modules/smiles-drawer/src/Ring.js
var require_Ring = __commonJS({
  "node_modules/smiles-drawer/src/Ring.js"(exports, module2) {
    var ArrayHelper = require_ArrayHelper();
    var Vector2 = require_Vector2();
    var Vertex = require_Vertex();
    var RingConnection = require_RingConnection();
    var Ring = class {
      constructor(members) {
        this.id = null;
        this.members = members;
        this.edges = [];
        this.insiders = [];
        this.neighbours = [];
        this.positioned = false;
        this.center = new Vector2(0, 0);
        this.rings = [];
        this.isBridged = false;
        this.isPartOfBridged = false;
        this.isSpiro = false;
        this.isFused = false;
        this.centralAngle = 0;
        this.canFlip = true;
      }
      clone() {
        let clone = new Ring(this.members);
        clone.id = this.id;
        clone.insiders = ArrayHelper.clone(this.insiders);
        clone.neighbours = ArrayHelper.clone(this.neighbours);
        clone.positioned = this.positioned;
        clone.center = this.center.clone();
        clone.rings = ArrayHelper.clone(this.rings);
        clone.isBridged = this.isBridged;
        clone.isPartOfBridged = this.isPartOfBridged;
        clone.isSpiro = this.isSpiro;
        clone.isFused = this.isFused;
        clone.centralAngle = this.centralAngle;
        clone.canFlip = this.canFlip;
        return clone;
      }
      getSize() {
        return this.members.length;
      }
      getPolygon(vertices) {
        let polygon = [];
        for (let i = 0; i < this.members.length; i++) {
          polygon.push(vertices[this.members[i]].position);
        }
        return polygon;
      }
      getAngle() {
        return Math.PI - this.centralAngle;
      }
      eachMember(vertices, callback, startVertexId, previousVertexId) {
        startVertexId = startVertexId || startVertexId === 0 ? startVertexId : this.members[0];
        let current = startVertexId;
        let max = 0;
        while (current != null && max < 100) {
          let prev = current;
          callback(prev);
          current = vertices[current].getNextInRing(vertices, this.id, previousVertexId);
          previousVertexId = prev;
          if (current == startVertexId) {
            current = null;
          }
          max++;
        }
      }
      getOrderedNeighbours(ringConnections) {
        let orderedNeighbours = Array(this.neighbours.length);
        for (let i = 0; i < this.neighbours.length; i++) {
          let vertices = RingConnection.getVertices(ringConnections, this.id, this.neighbours[i]);
          orderedNeighbours[i] = {
            n: vertices.length,
            neighbour: this.neighbours[i]
          };
        }
        orderedNeighbours.sort(function(a, b) {
          return b.n - a.n;
        });
        return orderedNeighbours;
      }
      isBenzeneLike(vertices) {
        let db = this.getDoubleBondCount(vertices);
        let length = this.members.length;
        return db === 3 && length === 6 || db === 2 && length === 5;
      }
      getDoubleBondCount(vertices) {
        let doubleBondCount = 0;
        for (let i = 0; i < this.members.length; i++) {
          let atom = vertices[this.members[i]].value;
          if (atom.bondType === "=" || atom.branchBond === "=") {
            doubleBondCount++;
          }
        }
        return doubleBondCount;
      }
      contains(vertexId) {
        for (let i = 0; i < this.members.length; i++) {
          if (this.members[i] == vertexId) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Ring;
  }
});

// node_modules/smiles-drawer/src/Atom.js
var require_Atom = __commonJS({
  "node_modules/smiles-drawer/src/Atom.js"(exports, module2) {
    var ArrayHelper = require_ArrayHelper();
    var Vertex = require_Vertex();
    var Ring = require_Ring();
    var Atom = class {
      constructor(element, bondType = "-") {
        this.element = element.length === 1 ? element.toUpperCase() : element;
        this.drawExplicit = false;
        this.ringbonds = Array();
        this.rings = Array();
        this.bondType = bondType;
        this.branchBond = null;
        this.isBridge = false;
        this.isBridgeNode = false;
        this.originalRings = Array();
        this.bridgedRing = null;
        this.anchoredRings = Array();
        this.bracket = null;
        this.plane = 0;
        this.attachedPseudoElements = {};
        this.hasAttachedPseudoElements = false;
        this.isDrawn = true;
        this.isConnectedToRing = false;
        this.neighbouringElements = Array();
        this.isPartOfAromaticRing = element !== this.element;
        this.bondCount = 0;
        this.chirality = "";
        this.isStereoCenter = false;
        this.priority = 0;
        this.mainChain = false;
        this.hydrogenDirection = "down";
        this.subtreeDepth = 1;
        this.hasHydrogen = false;
      }
      addNeighbouringElement(element) {
        this.neighbouringElements.push(element);
      }
      attachPseudoElement(element, previousElement, hydrogenCount = 0, charge = 0) {
        if (hydrogenCount === null) {
          hydrogenCount = 0;
        }
        if (charge === null) {
          charge = 0;
        }
        let key = hydrogenCount + element + charge;
        if (this.attachedPseudoElements[key]) {
          this.attachedPseudoElements[key].count += 1;
        } else {
          this.attachedPseudoElements[key] = {
            element,
            count: 1,
            hydrogenCount,
            previousElement,
            charge
          };
        }
        this.hasAttachedPseudoElements = true;
      }
      getAttachedPseudoElements() {
        let ordered = {};
        let that = this;
        Object.keys(this.attachedPseudoElements).sort().forEach(function(key) {
          ordered[key] = that.attachedPseudoElements[key];
        });
        return ordered;
      }
      getAttachedPseudoElementsCount() {
        return Object.keys(this.attachedPseudoElements).length;
      }
      isHeteroAtom() {
        return this.element !== "C" && this.element !== "H";
      }
      addAnchoredRing(ringId) {
        if (!ArrayHelper.contains(this.anchoredRings, {
          value: ringId
        })) {
          this.anchoredRings.push(ringId);
        }
      }
      getRingbondCount() {
        return this.ringbonds.length;
      }
      backupRings() {
        this.originalRings = Array(this.rings.length);
        for (let i = 0; i < this.rings.length; i++) {
          this.originalRings[i] = this.rings[i];
        }
      }
      restoreRings() {
        this.rings = Array(this.originalRings.length);
        for (let i = 0; i < this.originalRings.length; i++) {
          this.rings[i] = this.originalRings[i];
        }
      }
      haveCommonRingbond(atomA, atomB) {
        for (let i = 0; i < atomA.ringbonds.length; i++) {
          for (let j = 0; j < atomB.ringbonds.length; j++) {
            if (atomA.ringbonds[i].id == atomB.ringbonds[j].id) {
              return true;
            }
          }
        }
        return false;
      }
      neighbouringElementsEqual(arr) {
        if (arr.length !== this.neighbouringElements.length) {
          return false;
        }
        arr.sort();
        this.neighbouringElements.sort();
        for (var i = 0; i < this.neighbouringElements.length; i++) {
          if (arr[i] !== this.neighbouringElements[i]) {
            return false;
          }
        }
        return true;
      }
      getAtomicNumber() {
        return Atom.atomicNumbers[this.element];
      }
      getMaxBonds() {
        return Atom.maxBonds[this.element];
      }
      static get maxBonds() {
        return {
          "H": 1,
          "C": 4,
          "N": 3,
          "O": 2,
          "P": 3,
          "S": 2,
          "B": 3,
          "F": 1,
          "I": 1,
          "Cl": 1,
          "Br": 1
        };
      }
      static get atomicNumbers() {
        return {
          "H": 1,
          "He": 2,
          "Li": 3,
          "Be": 4,
          "B": 5,
          "b": 5,
          "C": 6,
          "c": 6,
          "N": 7,
          "n": 7,
          "O": 8,
          "o": 8,
          "F": 9,
          "Ne": 10,
          "Na": 11,
          "Mg": 12,
          "Al": 13,
          "Si": 14,
          "P": 15,
          "p": 15,
          "S": 16,
          "s": 16,
          "Cl": 17,
          "Ar": 18,
          "K": 19,
          "Ca": 20,
          "Sc": 21,
          "Ti": 22,
          "V": 23,
          "Cr": 24,
          "Mn": 25,
          "Fe": 26,
          "Co": 27,
          "Ni": 28,
          "Cu": 29,
          "Zn": 30,
          "Ga": 31,
          "Ge": 32,
          "As": 33,
          "Se": 34,
          "Br": 35,
          "Kr": 36,
          "Rb": 37,
          "Sr": 38,
          "Y": 39,
          "Zr": 40,
          "Nb": 41,
          "Mo": 42,
          "Tc": 43,
          "Ru": 44,
          "Rh": 45,
          "Pd": 46,
          "Ag": 47,
          "Cd": 48,
          "In": 49,
          "Sn": 50,
          "Sb": 51,
          "Te": 52,
          "I": 53,
          "Xe": 54,
          "Cs": 55,
          "Ba": 56,
          "La": 57,
          "Ce": 58,
          "Pr": 59,
          "Nd": 60,
          "Pm": 61,
          "Sm": 62,
          "Eu": 63,
          "Gd": 64,
          "Tb": 65,
          "Dy": 66,
          "Ho": 67,
          "Er": 68,
          "Tm": 69,
          "Yb": 70,
          "Lu": 71,
          "Hf": 72,
          "Ta": 73,
          "W": 74,
          "Re": 75,
          "Os": 76,
          "Ir": 77,
          "Pt": 78,
          "Au": 79,
          "Hg": 80,
          "Tl": 81,
          "Pb": 82,
          "Bi": 83,
          "Po": 84,
          "At": 85,
          "Rn": 86,
          "Fr": 87,
          "Ra": 88,
          "Ac": 89,
          "Th": 90,
          "Pa": 91,
          "U": 92,
          "Np": 93,
          "Pu": 94,
          "Am": 95,
          "Cm": 96,
          "Bk": 97,
          "Cf": 98,
          "Es": 99,
          "Fm": 100,
          "Md": 101,
          "No": 102,
          "Lr": 103,
          "Rf": 104,
          "Db": 105,
          "Sg": 106,
          "Bh": 107,
          "Hs": 108,
          "Mt": 109,
          "Ds": 110,
          "Rg": 111,
          "Cn": 112,
          "Uut": 113,
          "Uuq": 114,
          "Uup": 115,
          "Uuh": 116,
          "Uus": 117,
          "Uuo": 118
        };
      }
      static get mass() {
        return {
          "H": 1,
          "He": 2,
          "Li": 3,
          "Be": 4,
          "B": 5,
          "b": 5,
          "C": 6,
          "c": 6,
          "N": 7,
          "n": 7,
          "O": 8,
          "o": 8,
          "F": 9,
          "Ne": 10,
          "Na": 11,
          "Mg": 12,
          "Al": 13,
          "Si": 14,
          "P": 15,
          "p": 15,
          "S": 16,
          "s": 16,
          "Cl": 17,
          "Ar": 18,
          "K": 19,
          "Ca": 20,
          "Sc": 21,
          "Ti": 22,
          "V": 23,
          "Cr": 24,
          "Mn": 25,
          "Fe": 26,
          "Co": 27,
          "Ni": 28,
          "Cu": 29,
          "Zn": 30,
          "Ga": 31,
          "Ge": 32,
          "As": 33,
          "Se": 34,
          "Br": 35,
          "Kr": 36,
          "Rb": 37,
          "Sr": 38,
          "Y": 39,
          "Zr": 40,
          "Nb": 41,
          "Mo": 42,
          "Tc": 43,
          "Ru": 44,
          "Rh": 45,
          "Pd": 46,
          "Ag": 47,
          "Cd": 48,
          "In": 49,
          "Sn": 50,
          "Sb": 51,
          "Te": 52,
          "I": 53,
          "Xe": 54,
          "Cs": 55,
          "Ba": 56,
          "La": 57,
          "Ce": 58,
          "Pr": 59,
          "Nd": 60,
          "Pm": 61,
          "Sm": 62,
          "Eu": 63,
          "Gd": 64,
          "Tb": 65,
          "Dy": 66,
          "Ho": 67,
          "Er": 68,
          "Tm": 69,
          "Yb": 70,
          "Lu": 71,
          "Hf": 72,
          "Ta": 73,
          "W": 74,
          "Re": 75,
          "Os": 76,
          "Ir": 77,
          "Pt": 78,
          "Au": 79,
          "Hg": 80,
          "Tl": 81,
          "Pb": 82,
          "Bi": 83,
          "Po": 84,
          "At": 85,
          "Rn": 86,
          "Fr": 87,
          "Ra": 88,
          "Ac": 89,
          "Th": 90,
          "Pa": 91,
          "U": 92,
          "Np": 93,
          "Pu": 94,
          "Am": 95,
          "Cm": 96,
          "Bk": 97,
          "Cf": 98,
          "Es": 99,
          "Fm": 100,
          "Md": 101,
          "No": 102,
          "Lr": 103,
          "Rf": 104,
          "Db": 105,
          "Sg": 106,
          "Bh": 107,
          "Hs": 108,
          "Mt": 109,
          "Ds": 110,
          "Rg": 111,
          "Cn": 112,
          "Uut": 113,
          "Uuq": 114,
          "Uup": 115,
          "Uuh": 116,
          "Uus": 117,
          "Uuo": 118
        };
      }
    };
    module2.exports = Atom;
  }
});

// node_modules/smiles-drawer/src/Vertex.js
var require_Vertex = __commonJS({
  "node_modules/smiles-drawer/src/Vertex.js"(exports, module2) {
    var MathHelper2 = require_MathHelper();
    var ArrayHelper = require_ArrayHelper();
    var Vector2 = require_Vector2();
    var Atom = require_Atom();
    var Vertex = class {
      constructor(value, x = 0, y = 0) {
        this.id = null;
        this.value = value;
        this.position = new Vector2(x ? x : 0, y ? y : 0);
        this.previousPosition = new Vector2(0, 0);
        this.parentVertexId = null;
        this.children = Array();
        this.spanningTreeChildren = Array();
        this.edges = Array();
        this.positioned = false;
        this.angle = null;
        this.dir = 1;
        this.neighbourCount = 0;
        this.neighbours = Array();
        this.neighbouringElements = Array();
        this.forcePositioned = false;
      }
      setPosition(x, y) {
        this.position.x = x;
        this.position.y = y;
      }
      setPositionFromVector(v) {
        this.position.x = v.x;
        this.position.y = v.y;
      }
      addChild(vertexId) {
        this.children.push(vertexId);
        this.neighbours.push(vertexId);
        this.neighbourCount++;
      }
      addRingbondChild(vertexId, ringbondIndex) {
        this.children.push(vertexId);
        if (this.value.bracket) {
          let index = 1;
          if (this.id === 0 && this.value.bracket.hcount === 0) {
            index = 0;
          }
          if (this.value.bracket.hcount === 1 && ringbondIndex === 0) {
            index = 2;
          }
          if (this.value.bracket.hcount === 1 && ringbondIndex === 1) {
            if (this.neighbours.length < 3) {
              index = 2;
            } else {
              index = 3;
            }
          }
          if (this.value.bracket.hcount === null && ringbondIndex === 0) {
            index = 1;
          }
          if (this.value.bracket.hcount === null && ringbondIndex === 1) {
            if (this.neighbours.length < 3) {
              index = 1;
            } else {
              index = 2;
            }
          }
          this.neighbours.splice(index, 0, vertexId);
        } else {
          this.neighbours.push(vertexId);
        }
        this.neighbourCount++;
      }
      setParentVertexId(parentVertexId) {
        this.neighbourCount++;
        this.parentVertexId = parentVertexId;
        this.neighbours.push(parentVertexId);
      }
      isTerminal() {
        if (this.value.hasAttachedPseudoElements) {
          return true;
        }
        return this.parentVertexId === null && this.children.length < 2 || this.children.length === 0;
      }
      clone() {
        let clone = new Vertex(this.value, this.position.x, this.position.y);
        clone.id = this.id;
        clone.previousPosition = new Vector2(this.previousPosition.x, this.previousPosition.y);
        clone.parentVertexId = this.parentVertexId;
        clone.children = ArrayHelper.clone(this.children);
        clone.spanningTreeChildren = ArrayHelper.clone(this.spanningTreeChildren);
        clone.edges = ArrayHelper.clone(this.edges);
        clone.positioned = this.positioned;
        clone.angle = this.angle;
        clone.forcePositioned = this.forcePositioned;
        return clone;
      }
      equals(vertex) {
        return this.id === vertex.id;
      }
      getAngle(referenceVector = null, returnAsDegrees = false) {
        let u = null;
        if (!referenceVector) {
          u = Vector2.subtract(this.position, this.previousPosition);
        } else {
          u = Vector2.subtract(this.position, referenceVector);
        }
        if (returnAsDegrees) {
          return MathHelper2.toDeg(u.angle());
        }
        return u.angle();
      }
      getTextDirection(vertices) {
        let neighbours = this.getDrawnNeighbours(vertices);
        let angles = Array();
        for (let i = 0; i < neighbours.length; i++) {
          angles.push(this.getAngle(vertices[neighbours[i]].position));
        }
        let textAngle = MathHelper2.meanAngle(angles);
        let halfPi = Math.PI / 2;
        textAngle = Math.round(Math.round(textAngle / halfPi) * halfPi);
        if (textAngle === 2) {
          return "down";
        } else if (textAngle === -2) {
          return "up";
        } else if (textAngle === 0 || textAngle === -0) {
          return "right";
        } else if (textAngle === 3 || textAngle === -3) {
          return "left";
        } else {
          return "down";
        }
      }
      getNeighbours(vertexId = null) {
        if (vertexId === null) {
          return this.neighbours.slice();
        }
        let arr = Array();
        for (let i = 0; i < this.neighbours.length; i++) {
          if (this.neighbours[i] !== vertexId) {
            arr.push(this.neighbours[i]);
          }
        }
        return arr;
      }
      getDrawnNeighbours(vertices) {
        let arr = Array();
        for (let i = 0; i < this.neighbours.length; i++) {
          if (vertices[this.neighbours[i]].value.isDrawn) {
            arr.push(this.neighbours[i]);
          }
        }
        return arr;
      }
      getNeighbourCount() {
        return this.neighbourCount;
      }
      getSpanningTreeNeighbours(vertexId = null) {
        let neighbours = Array();
        for (let i = 0; i < this.spanningTreeChildren.length; i++) {
          if (vertexId === void 0 || vertexId != this.spanningTreeChildren[i]) {
            neighbours.push(this.spanningTreeChildren[i]);
          }
        }
        if (this.parentVertexId != null) {
          if (vertexId === void 0 || vertexId != this.parentVertexId) {
            neighbours.push(this.parentVertexId);
          }
        }
        return neighbours;
      }
      getNextInRing(vertices, ringId, previousVertexId) {
        let neighbours = this.getNeighbours();
        for (let i = 0; i < neighbours.length; i++) {
          if (ArrayHelper.contains(vertices[neighbours[i]].value.rings, {
            value: ringId
          }) && neighbours[i] != previousVertexId) {
            return neighbours[i];
          }
        }
        return null;
      }
    };
    module2.exports = Vertex;
  }
});

// node_modules/smiles-drawer/src/Edge.js
var require_Edge = __commonJS({
  "node_modules/smiles-drawer/src/Edge.js"(exports, module2) {
    var Edge = class {
      constructor(sourceId, targetId, weight = 1) {
        this.id = null;
        this.sourceId = sourceId;
        this.targetId = targetId;
        this.weight = weight;
        this.bondType = "-";
        this.isPartOfAromaticRing = false;
        this.center = false;
        this.wedge = "";
      }
      setBondType(bondType) {
        this.bondType = bondType;
        this.weight = Edge.bonds[bondType];
      }
      static get bonds() {
        return {
          "-": 1,
          "/": 1,
          "\\": 1,
          "=": 2,
          "#": 3,
          "$": 4
        };
      }
    };
    module2.exports = Edge;
  }
});

// node_modules/smiles-drawer/src/UtilityFunctions.js
var require_UtilityFunctions = __commonJS({
  "node_modules/smiles-drawer/src/UtilityFunctions.js"(exports, module2) {
    function getChargeText(charge) {
      console.log("in the utility version of getChargeText");
      if (charge === 1) {
        return "+";
      } else if (charge === 2) {
        return "2+";
      } else if (charge === -1) {
        return "-";
      } else if (charge === -2) {
        return "2-";
      } else {
        return "";
      }
    }
    module2.exports = {
      getChargeText
    };
  }
});

// node_modules/smiles-drawer/src/CanvasWrapper.js
var require_CanvasWrapper = __commonJS({
  "node_modules/smiles-drawer/src/CanvasWrapper.js"(exports, module2) {
    var MathHelper2 = require_MathHelper();
    var Vector2 = require_Vector2();
    var Line = require_Line();
    var Vertex = require_Vertex();
    var Ring = require_Ring();
    var { getChargeText } = require_UtilityFunctions();
    var CanvasWrapper = class {
      constructor(target, themeManager, options) {
        if (typeof target === "string" || target instanceof String) {
          this.canvas = document.getElementById(target);
        } else {
          this.canvas = target;
        }
        this.ctx = this.canvas.getContext("2d");
        this.themeManager = themeManager;
        this.opts = options;
        this.drawingWidth = 0;
        this.drawingHeight = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.fontLarge = this.opts.fontSizeLarge + "pt Helvetica, Arial, sans-serif";
        this.fontSmall = this.opts.fontSizeSmall + "pt Helvetica, Arial, sans-serif";
        this.updateSize(this.opts.width, this.opts.height);
        this.ctx.font = this.fontLarge;
        this.hydrogenWidth = this.ctx.measureText("H").width;
        this.halfHydrogenWidth = this.hydrogenWidth / 2;
        this.halfBondThickness = this.opts.bondThickness / 2;
      }
      updateSize(width, height) {
        this.devicePixelRatio = window.devicePixelRatio || 1;
        this.backingStoreRatio = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1;
        this.ratio = this.devicePixelRatio / this.backingStoreRatio;
        if (this.ratio !== 1) {
          this.canvas.width = width * this.ratio;
          this.canvas.height = height * this.ratio;
          this.canvas.style.width = width + "px";
          this.canvas.style.height = height + "px";
          this.ctx.setTransform(this.ratio, 0, 0, this.ratio, 0, 0);
        } else {
          this.canvas.width = width * this.ratio;
          this.canvas.height = height * this.ratio;
        }
      }
      setTheme(theme) {
        this.colors = theme;
      }
      scale(vertices) {
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        for (var i = 0; i < vertices.length; i++) {
          if (!vertices[i].value.isDrawn) {
            continue;
          }
          let p = vertices[i].position;
          if (maxX < p.x)
            maxX = p.x;
          if (maxY < p.y)
            maxY = p.y;
          if (minX > p.x)
            minX = p.x;
          if (minY > p.y)
            minY = p.y;
        }
        var padding = this.opts.padding;
        maxX += padding;
        maxY += padding;
        minX -= padding;
        minY -= padding;
        this.drawingWidth = maxX - minX;
        this.drawingHeight = maxY - minY;
        var scaleX = this.canvas.offsetWidth / this.drawingWidth;
        var scaleY = this.canvas.offsetHeight / this.drawingHeight;
        var scale = scaleX < scaleY ? scaleX : scaleY;
        this.ctx.scale(scale, scale);
        this.offsetX = -minX;
        this.offsetY = -minY;
        if (scaleX < scaleY) {
          this.offsetY += this.canvas.offsetHeight / (2 * scale) - this.drawingHeight / 2;
        } else {
          this.offsetX += this.canvas.offsetWidth / (2 * scale) - this.drawingWidth / 2;
        }
      }
      reset() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      getColor(key) {
        key = key.toUpperCase();
        if (key in this.colors) {
          return this.colors[key];
        }
        return this.colors["C"];
      }
      drawCircle(x, y, radius, color, fill = true, debug = false, debugText = "") {
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        ctx.save();
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(x + offsetX, y + offsetY, radius, 0, MathHelper2.twoPI, true);
        ctx.closePath();
        if (debug) {
          if (fill) {
            ctx.fillStyle = "#f00";
            ctx.fill();
          } else {
            ctx.strokeStyle = "#f00";
            ctx.stroke();
          }
          this.drawDebugText(x, y, debugText);
        } else {
          if (fill) {
            ctx.fillStyle = color;
            ctx.fill();
          } else {
            ctx.strokeStyle = color;
            ctx.stroke();
          }
        }
        ctx.restore();
      }
      drawLine(line, dashed = false, alpha = 1) {
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        let shortLine = line.clone().shorten(4);
        let l = shortLine.getLeftVector().clone();
        let r = shortLine.getRightVector().clone();
        l.x += offsetX;
        l.y += offsetY;
        r.x += offsetX;
        r.y += offsetY;
        if (!dashed) {
          ctx.save();
          ctx.globalCompositeOperation = "destination-out";
          ctx.beginPath();
          ctx.moveTo(l.x, l.y);
          ctx.lineTo(r.x, r.y);
          ctx.lineCap = "round";
          ctx.lineWidth = this.opts.bondThickness + 1.2;
          ctx.strokeStyle = this.themeManager.getColor("BACKGROUND");
          ctx.stroke();
          ctx.globalCompositeOperation = "source-over";
          ctx.restore();
        }
        l = line.getLeftVector().clone();
        r = line.getRightVector().clone();
        l.x += offsetX;
        l.y += offsetY;
        r.x += offsetX;
        r.y += offsetY;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(l.x, l.y);
        ctx.lineTo(r.x, r.y);
        ctx.lineCap = "round";
        ctx.lineWidth = this.opts.bondThickness;
        let gradient = this.ctx.createLinearGradient(l.x, l.y, r.x, r.y);
        gradient.addColorStop(0.4, this.themeManager.getColor(line.getLeftElement()) || this.themeManager.getColor("C"));
        gradient.addColorStop(0.6, this.themeManager.getColor(line.getRightElement()) || this.themeManager.getColor("C"));
        if (dashed) {
          ctx.setLineDash([1, 1.5]);
          ctx.lineWidth = this.opts.bondThickness / 1.5;
        }
        if (alpha < 1) {
          ctx.globalAlpha = alpha;
        }
        ctx.strokeStyle = gradient;
        ctx.stroke();
        ctx.restore();
      }
      drawWedge(line, width = 1) {
        if (isNaN(line.from.x) || isNaN(line.from.y) || isNaN(line.to.x) || isNaN(line.to.y)) {
          return;
        }
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        let shortLine = line.clone().shorten(5);
        let l = shortLine.getLeftVector().clone();
        let r = shortLine.getRightVector().clone();
        l.x += offsetX;
        l.y += offsetY;
        r.x += offsetX;
        r.y += offsetY;
        l = line.getLeftVector().clone();
        r = line.getRightVector().clone();
        l.x += offsetX;
        l.y += offsetY;
        r.x += offsetX;
        r.y += offsetY;
        ctx.save();
        let normals = Vector2.normals(l, r);
        normals[0].normalize();
        normals[1].normalize();
        let isRightChiralCenter = line.getRightChiral();
        let start = l;
        let end = r;
        if (isRightChiralCenter) {
          start = r;
          end = l;
        }
        let t = Vector2.add(start, Vector2.multiplyScalar(normals[0], this.halfBondThickness));
        let u = Vector2.add(end, Vector2.multiplyScalar(normals[0], 1.5 + this.halfBondThickness));
        let v = Vector2.add(end, Vector2.multiplyScalar(normals[1], 1.5 + this.halfBondThickness));
        let w = Vector2.add(start, Vector2.multiplyScalar(normals[1], this.halfBondThickness));
        ctx.beginPath();
        ctx.moveTo(t.x, t.y);
        ctx.lineTo(u.x, u.y);
        ctx.lineTo(v.x, v.y);
        ctx.lineTo(w.x, w.y);
        let gradient = this.ctx.createRadialGradient(r.x, r.y, this.opts.bondLength, r.x, r.y, 0);
        gradient.addColorStop(0.4, this.themeManager.getColor(line.getLeftElement()) || this.themeManager.getColor("C"));
        gradient.addColorStop(0.6, this.themeManager.getColor(line.getRightElement()) || this.themeManager.getColor("C"));
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.restore();
      }
      drawDashedWedge(line) {
        if (isNaN(line.from.x) || isNaN(line.from.y) || isNaN(line.to.x) || isNaN(line.to.y)) {
          return;
        }
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        let l = line.getLeftVector().clone();
        let r = line.getRightVector().clone();
        l.x += offsetX;
        l.y += offsetY;
        r.x += offsetX;
        r.y += offsetY;
        ctx.save();
        let normals = Vector2.normals(l, r);
        normals[0].normalize();
        normals[1].normalize();
        let isRightChiralCenter = line.getRightChiral();
        let start;
        let end;
        let sStart;
        let sEnd;
        let shortLine = line.clone();
        if (isRightChiralCenter) {
          start = r;
          end = l;
          shortLine.shortenRight(1);
          sStart = shortLine.getRightVector().clone();
          sEnd = shortLine.getLeftVector().clone();
        } else {
          start = l;
          end = r;
          shortLine.shortenLeft(1);
          sStart = shortLine.getLeftVector().clone();
          sEnd = shortLine.getRightVector().clone();
        }
        sStart.x += offsetX;
        sStart.y += offsetY;
        sEnd.x += offsetX;
        sEnd.y += offsetY;
        let dir = Vector2.subtract(end, start).normalize();
        ctx.strokeStyle = this.themeManager.getColor("C");
        ctx.lineCap = "round";
        ctx.lineWidth = this.opts.bondThickness;
        ctx.beginPath();
        let length = line.getLength();
        let step = 1.25 / (length / (this.opts.bondThickness * 3));
        let changed = false;
        for (var t = 0; t < 1; t += step) {
          let to = Vector2.multiplyScalar(dir, t * length);
          let startDash = Vector2.add(start, to);
          let width = 1.5 * t;
          let dashOffset = Vector2.multiplyScalar(normals[0], width);
          if (!changed && t > 0.5) {
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = this.themeManager.getColor(line.getRightElement()) || this.themeManager.getColor("C");
            changed = true;
          }
          startDash.subtract(dashOffset);
          ctx.moveTo(startDash.x, startDash.y);
          startDash.add(Vector2.multiplyScalar(dashOffset, 2));
          ctx.lineTo(startDash.x, startDash.y);
        }
        ctx.stroke();
        ctx.restore();
      }
      drawDebugText(x, y, text) {
        let ctx = this.ctx;
        ctx.save();
        ctx.font = "5px Droid Sans, sans-serif";
        ctx.textAlign = "start";
        ctx.textBaseline = "top";
        ctx.fillStyle = "#ff0000";
        ctx.fillText(text, x + this.offsetX, y + this.offsetY);
        ctx.restore();
      }
      drawBall(x, y, elementName) {
        let ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x + this.offsetX, y + this.offsetY, this.opts.bondLength / 4.5, 0, MathHelper2.twoPI, false);
        ctx.fillStyle = this.themeManager.getColor(elementName);
        ctx.fill();
        ctx.restore();
      }
      drawPoint(x, y, elementName) {
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        ctx.save();
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(x + offsetX, y + offsetY, 1.5, 0, MathHelper2.twoPI, true);
        ctx.closePath();
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";
        ctx.beginPath();
        ctx.arc(x + this.offsetX, y + this.offsetY, 0.75, 0, MathHelper2.twoPI, false);
        ctx.fillStyle = this.themeManager.getColor(elementName);
        ctx.fill();
        ctx.restore();
      }
      drawText(x, y, elementName, hydrogens, direction, isTerminal, charge, isotope, attachedPseudoElement = {}) {
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        ctx.save();
        ctx.textAlign = "start";
        ctx.textBaseline = "alphabetic";
        let pseudoElementHandled = false;
        let chargeText = "";
        let chargeWidth = 0;
        if (charge) {
          chargeText = getChargeText(charge);
          ctx.font = this.fontSmall;
          chargeWidth = ctx.measureText(chargeText).width;
        }
        let isotopeText = "0";
        let isotopeWidth = 0;
        if (isotope > 0) {
          isotopeText = isotope.toString();
          ctx.font = this.fontSmall;
          isotopeWidth = ctx.measureText(isotopeText).width;
        }
        if (charge === 1 && elementName === "N" && attachedPseudoElement.hasOwnProperty("0O") && attachedPseudoElement.hasOwnProperty("0O-1")) {
          attachedPseudoElement = { "0O": { element: "O", count: 2, hydrogenCount: 0, previousElement: "C", charge: "" } };
          charge = 0;
        }
        ctx.font = this.fontLarge;
        ctx.fillStyle = this.themeManager.getColor("BACKGROUND");
        let dim = ctx.measureText(elementName);
        dim.totalWidth = dim.width + chargeWidth;
        dim.height = parseInt(this.fontLarge, 10);
        let r = dim.width > this.opts.fontSizeLarge ? dim.width : this.opts.fontSizeLarge;
        r /= 1.5;
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(x + offsetX, y + offsetY, r, 0, MathHelper2.twoPI, true);
        ctx.closePath();
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";
        let cursorPos = -dim.width / 2;
        let cursorPosLeft = -dim.width / 2;
        ctx.fillStyle = this.themeManager.getColor(elementName);
        ctx.fillText(elementName, x + offsetX + cursorPos, y + this.opts.halfFontSizeLarge + offsetY);
        cursorPos += dim.width;
        if (charge) {
          ctx.font = this.fontSmall;
          ctx.fillText(chargeText, x + offsetX + cursorPos, y - this.opts.fifthFontSizeSmall + offsetY);
          cursorPos += chargeWidth;
        }
        if (isotope > 0) {
          ctx.font = this.fontSmall;
          ctx.fillText(isotopeText, x + offsetX + cursorPosLeft - isotopeWidth, y - this.opts.fifthFontSizeSmall + offsetY);
          cursorPosLeft -= isotopeWidth;
        }
        ctx.font = this.fontLarge;
        let hydrogenWidth = 0;
        let hydrogenCountWidth = 0;
        if (hydrogens === 1) {
          let hx = x + offsetX;
          let hy = y + offsetY + this.opts.halfFontSizeLarge;
          hydrogenWidth = this.hydrogenWidth;
          cursorPosLeft -= hydrogenWidth;
          if (direction === "left") {
            hx += cursorPosLeft;
          } else if (direction === "right") {
            hx += cursorPos;
          } else if (direction === "up" && isTerminal) {
            hx += cursorPos;
          } else if (direction === "down" && isTerminal) {
            hx += cursorPos;
          } else if (direction === "up" && !isTerminal) {
            hy -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
            hx -= this.halfHydrogenWidth;
          } else if (direction === "down" && !isTerminal) {
            hy += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
            hx -= this.halfHydrogenWidth;
          }
          ctx.fillText("H", hx, hy);
          cursorPos += hydrogenWidth;
        } else if (hydrogens > 1) {
          let hx = x + offsetX;
          let hy = y + offsetY + this.opts.halfFontSizeLarge;
          hydrogenWidth = this.hydrogenWidth;
          ctx.font = this.fontSmall;
          hydrogenCountWidth = ctx.measureText(hydrogens).width;
          cursorPosLeft -= hydrogenWidth + hydrogenCountWidth;
          if (direction === "left") {
            hx += cursorPosLeft;
          } else if (direction === "right") {
            hx += cursorPos;
          } else if (direction === "up" && isTerminal) {
            hx += cursorPos;
          } else if (direction === "down" && isTerminal) {
            hx += cursorPos;
          } else if (direction === "up" && !isTerminal) {
            hy -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
            hx -= this.halfHydrogenWidth;
          } else if (direction === "down" && !isTerminal) {
            hy += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
            hx -= this.halfHydrogenWidth;
          }
          ctx.font = this.fontLarge;
          ctx.fillText("H", hx, hy);
          ctx.font = this.fontSmall;
          ctx.fillText(hydrogens, hx + this.halfHydrogenWidth + hydrogenCountWidth, hy + this.opts.fifthFontSizeSmall);
          cursorPos += hydrogenWidth + this.halfHydrogenWidth + hydrogenCountWidth;
        }
        if (pseudoElementHandled) {
          ctx.restore();
          return;
        }
        for (let key in attachedPseudoElement) {
          if (!attachedPseudoElement.hasOwnProperty(key)) {
            continue;
          }
          let openParenthesisWidth = 0;
          let closeParenthesisWidth = 0;
          let element = attachedPseudoElement[key].element;
          let elementCount = attachedPseudoElement[key].count;
          let hydrogenCount = attachedPseudoElement[key].hydrogenCount;
          let elementCharge = attachedPseudoElement[key].charge;
          ctx.font = this.fontLarge;
          if (elementCount > 1 && hydrogenCount > 0) {
            openParenthesisWidth = ctx.measureText("(").width;
            closeParenthesisWidth = ctx.measureText(")").width;
          }
          let elementWidth = ctx.measureText(element).width;
          let elementCountWidth = 0;
          let elementChargeText = "";
          let elementChargeWidth = 0;
          hydrogenWidth = 0;
          if (hydrogenCount > 0) {
            hydrogenWidth = this.hydrogenWidth;
          }
          ctx.font = this.fontSmall;
          if (elementCount > 1) {
            elementCountWidth = ctx.measureText(elementCount).width;
          }
          if (elementCharge !== 0) {
            elementChargeText = getChargeText(elementCharge);
            elementChargeWidth = ctx.measureText(elementChargeText).width;
          }
          hydrogenCountWidth = 0;
          if (hydrogenCount > 1) {
            hydrogenCountWidth = ctx.measureText(hydrogenCount).width;
          }
          ctx.font = this.fontLarge;
          let hx = x + offsetX;
          let hy = y + offsetY + this.opts.halfFontSizeLarge;
          ctx.fillStyle = this.themeManager.getColor(element);
          if (elementCount > 0) {
            cursorPosLeft -= elementCountWidth;
          }
          if (elementCount > 1 && hydrogenCount > 0) {
            if (direction === "left") {
              cursorPosLeft -= closeParenthesisWidth;
              ctx.fillText(")", hx + cursorPosLeft, hy);
            } else {
              ctx.fillText("(", hx + cursorPos, hy);
              cursorPos += openParenthesisWidth;
            }
          }
          if (direction === "left") {
            cursorPosLeft -= elementWidth;
            ctx.fillText(element, hx + cursorPosLeft, hy);
          } else {
            ctx.fillText(element, hx + cursorPos, hy);
            cursorPos += elementWidth;
          }
          if (hydrogenCount > 0) {
            if (direction === "left") {
              cursorPosLeft -= hydrogenWidth + hydrogenCountWidth;
              ctx.fillText("H", hx + cursorPosLeft, hy);
              if (hydrogenCount > 1) {
                ctx.font = this.fontSmall;
                ctx.fillText(hydrogenCount, hx + cursorPosLeft + hydrogenWidth, hy + this.opts.fifthFontSizeSmall);
              }
            } else {
              ctx.fillText("H", hx + cursorPos, hy);
              cursorPos += hydrogenWidth;
              if (hydrogenCount > 1) {
                ctx.font = this.fontSmall;
                ctx.fillText(hydrogenCount, hx + cursorPos, hy + this.opts.fifthFontSizeSmall);
                cursorPos += hydrogenCountWidth;
              }
            }
          }
          ctx.font = this.fontLarge;
          if (elementCount > 1 && hydrogenCount > 0) {
            if (direction === "left") {
              cursorPosLeft -= openParenthesisWidth;
              ctx.fillText("(", hx + cursorPosLeft, hy);
            } else {
              ctx.fillText(")", hx + cursorPos, hy);
              cursorPos += closeParenthesisWidth;
            }
          }
          ctx.font = this.fontSmall;
          if (elementCount > 1) {
            if (direction === "left") {
              ctx.fillText(elementCount, hx + cursorPosLeft + openParenthesisWidth + closeParenthesisWidth + hydrogenWidth + hydrogenCountWidth + elementWidth, hy + this.opts.fifthFontSizeSmall);
            } else {
              ctx.fillText(elementCount, hx + cursorPos, hy + this.opts.fifthFontSizeSmall);
              cursorPos += elementCountWidth;
            }
          }
          if (elementCharge !== 0) {
            if (direction === "left") {
              ctx.fillText(elementChargeText, hx + cursorPosLeft + openParenthesisWidth + closeParenthesisWidth + hydrogenWidth + hydrogenCountWidth + elementWidth, y - this.opts.fifthFontSizeSmall + offsetY);
            } else {
              ctx.fillText(elementChargeText, hx + cursorPos, y - this.opts.fifthFontSizeSmall + offsetY);
              cursorPos += elementChargeWidth;
            }
          }
        }
        ctx.restore();
      }
      getChargeText(charge) {
        if (charge === 1) {
          return "+";
        } else if (charge === 2) {
          return "2+";
        } else if (charge === -1) {
          return "-";
        } else if (charge === -2) {
          return "2-";
        } else {
          return "";
        }
      }
      drawDebugPoint(x, y, debugText = "", color = "#f00") {
        this.drawCircle(x, y, 2, color, true, true, debugText);
      }
      drawAromaticityRing(ring) {
        let ctx = this.ctx;
        let radius = MathHelper2.apothemFromSideLength(this.opts.bondLength, ring.getSize());
        ctx.save();
        ctx.strokeStyle = this.themeManager.getColor("C");
        ctx.lineWidth = this.opts.bondThickness;
        ctx.beginPath();
        ctx.arc(ring.center.x + this.offsetX, ring.center.y + this.offsetY, radius - this.opts.bondSpacing, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      clear() {
        this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight);
      }
    };
    module2.exports = CanvasWrapper;
  }
});

// node_modules/smiles-drawer/src/Graph.js
var require_Graph = __commonJS({
  "node_modules/smiles-drawer/src/Graph.js"(exports, module2) {
    var MathHelper2 = require_MathHelper();
    var Vector2 = require_Vector2();
    var Vertex = require_Vertex();
    var Edge = require_Edge();
    var Ring = require_Ring();
    var Atom = require_Atom();
    var Graph = class {
      constructor(parseTree, isomeric = false) {
        this.vertices = Array();
        this.edges = Array();
        this.vertexIdsToEdgeId = {};
        this.isomeric = isomeric;
        this._time = 0;
        this._init(parseTree);
      }
      _init(node, order = 0, parentVertexId = null, isBranch = false) {
        let atom = new Atom(node.atom.element ? node.atom.element : node.atom, node.bond);
        atom.branchBond = node.branchBond;
        atom.ringbonds = node.ringbonds;
        atom.bracket = node.atom.element ? node.atom : null;
        let vertex = new Vertex(atom);
        let parentVertex = this.vertices[parentVertexId];
        this.addVertex(vertex);
        if (parentVertexId !== null) {
          vertex.setParentVertexId(parentVertexId);
          vertex.value.addNeighbouringElement(parentVertex.value.element);
          parentVertex.addChild(vertex.id);
          parentVertex.value.addNeighbouringElement(atom.element);
          parentVertex.spanningTreeChildren.push(vertex.id);
          let edge = new Edge(parentVertexId, vertex.id, 1);
          let vertexId = null;
          if (isBranch) {
            edge.setBondType(vertex.value.branchBond || "-");
            vertexId = vertex.id;
            edge.setBondType(vertex.value.branchBond || "-");
            vertexId = vertex.id;
          } else {
            edge.setBondType(parentVertex.value.bondType || "-");
            vertexId = parentVertex.id;
          }
          let edgeId = this.addEdge(edge);
        }
        let offset = node.ringbondCount + 1;
        if (atom.bracket) {
          offset += atom.bracket.hcount;
        }
        let stereoHydrogens = 0;
        if (atom.bracket && atom.bracket.chirality) {
          atom.isStereoCenter = true;
          stereoHydrogens = atom.bracket.hcount;
          for (var i = 0; i < stereoHydrogens; i++) {
            this._init({
              atom: "H",
              isBracket: "false",
              branches: Array(),
              branchCount: 0,
              ringbonds: Array(),
              ringbondCount: false,
              next: null,
              hasNext: false,
              bond: "-"
            }, i, vertex.id, true);
          }
        }
        for (var i = 0; i < node.branchCount; i++) {
          this._init(node.branches[i], i + offset, vertex.id, true);
        }
        if (node.hasNext) {
          this._init(node.next, node.branchCount + offset, vertex.id);
        }
      }
      clear() {
        this.vertices = Array();
        this.edges = Array();
        this.vertexIdsToEdgeId = {};
      }
      addVertex(vertex) {
        vertex.id = this.vertices.length;
        this.vertices.push(vertex);
        return vertex.id;
      }
      addEdge(edge) {
        let source = this.vertices[edge.sourceId];
        let target = this.vertices[edge.targetId];
        edge.id = this.edges.length;
        this.edges.push(edge);
        this.vertexIdsToEdgeId[edge.sourceId + "_" + edge.targetId] = edge.id;
        this.vertexIdsToEdgeId[edge.targetId + "_" + edge.sourceId] = edge.id;
        edge.isPartOfAromaticRing = source.value.isPartOfAromaticRing && target.value.isPartOfAromaticRing;
        source.value.bondCount += edge.weight;
        target.value.bondCount += edge.weight;
        source.edges.push(edge.id);
        target.edges.push(edge.id);
        return edge.id;
      }
      getEdge(vertexIdA, vertexIdB) {
        let edgeId = this.vertexIdsToEdgeId[vertexIdA + "_" + vertexIdB];
        return edgeId === void 0 ? null : this.edges[edgeId];
      }
      getEdges(vertexId) {
        let edgeIds = Array();
        let vertex = this.vertices[vertexId];
        for (var i = 0; i < vertex.neighbours.length; i++) {
          edgeIds.push(this.vertexIdsToEdgeId[vertexId + "_" + vertex.neighbours[i]]);
        }
        return edgeIds;
      }
      hasEdge(vertexIdA, vertexIdB) {
        return this.vertexIdsToEdgeId[vertexIdA + "_" + vertexIdB] !== void 0;
      }
      getVertexList() {
        let arr = [this.vertices.length];
        for (var i = 0; i < this.vertices.length; i++) {
          arr[i] = this.vertices[i].id;
        }
        return arr;
      }
      getEdgeList() {
        let arr = Array(this.edges.length);
        for (var i = 0; i < this.edges.length; i++) {
          arr[i] = [this.edges[i].sourceId, this.edges[i].targetId];
        }
        return arr;
      }
      getAdjacencyMatrix() {
        let length = this.vertices.length;
        let adjacencyMatrix = Array(length);
        for (var i = 0; i < length; i++) {
          adjacencyMatrix[i] = new Array(length);
          adjacencyMatrix[i].fill(0);
        }
        for (var i = 0; i < this.edges.length; i++) {
          let edge = this.edges[i];
          adjacencyMatrix[edge.sourceId][edge.targetId] = 1;
          adjacencyMatrix[edge.targetId][edge.sourceId] = 1;
        }
        return adjacencyMatrix;
      }
      getComponentsAdjacencyMatrix() {
        let length = this.vertices.length;
        let adjacencyMatrix = Array(length);
        let bridges = this.getBridges();
        for (var i = 0; i < length; i++) {
          adjacencyMatrix[i] = new Array(length);
          adjacencyMatrix[i].fill(0);
        }
        for (var i = 0; i < this.edges.length; i++) {
          let edge = this.edges[i];
          adjacencyMatrix[edge.sourceId][edge.targetId] = 1;
          adjacencyMatrix[edge.targetId][edge.sourceId] = 1;
        }
        for (var i = 0; i < bridges.length; i++) {
          adjacencyMatrix[bridges[i][0]][bridges[i][1]] = 0;
          adjacencyMatrix[bridges[i][1]][bridges[i][0]] = 0;
        }
        return adjacencyMatrix;
      }
      getSubgraphAdjacencyMatrix(vertexIds) {
        let length = vertexIds.length;
        let adjacencyMatrix = Array(length);
        for (var i = 0; i < length; i++) {
          adjacencyMatrix[i] = new Array(length);
          adjacencyMatrix[i].fill(0);
          for (var j = 0; j < length; j++) {
            if (i === j) {
              continue;
            }
            if (this.hasEdge(vertexIds[i], vertexIds[j])) {
              adjacencyMatrix[i][j] = 1;
            }
          }
        }
        return adjacencyMatrix;
      }
      getDistanceMatrix() {
        let length = this.vertices.length;
        let adja = this.getAdjacencyMatrix();
        let dist = Array(length);
        for (var i = 0; i < length; i++) {
          dist[i] = Array(length);
          dist[i].fill(Infinity);
        }
        for (var i = 0; i < length; i++) {
          for (var j = 0; j < length; j++) {
            if (adja[i][j] === 1) {
              dist[i][j] = 1;
            }
          }
        }
        for (var k = 0; k < length; k++) {
          for (var i = 0; i < length; i++) {
            for (var j = 0; j < length; j++) {
              if (dist[i][j] > dist[i][k] + dist[k][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
              }
            }
          }
        }
        return dist;
      }
      getSubgraphDistanceMatrix(vertexIds) {
        let length = vertexIds.length;
        let adja = this.getSubgraphAdjacencyMatrix(vertexIds);
        let dist = Array(length);
        for (var i = 0; i < length; i++) {
          dist[i] = Array(length);
          dist[i].fill(Infinity);
        }
        for (var i = 0; i < length; i++) {
          for (var j = 0; j < length; j++) {
            if (adja[i][j] === 1) {
              dist[i][j] = 1;
            }
          }
        }
        for (var k = 0; k < length; k++) {
          for (var i = 0; i < length; i++) {
            for (var j = 0; j < length; j++) {
              if (dist[i][j] > dist[i][k] + dist[k][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
              }
            }
          }
        }
        return dist;
      }
      getAdjacencyList() {
        let length = this.vertices.length;
        let adjacencyList = Array(length);
        for (var i = 0; i < length; i++) {
          adjacencyList[i] = [];
          for (var j = 0; j < length; j++) {
            if (i === j) {
              continue;
            }
            if (this.hasEdge(this.vertices[i].id, this.vertices[j].id)) {
              adjacencyList[i].push(j);
            }
          }
        }
        return adjacencyList;
      }
      getSubgraphAdjacencyList(vertexIds) {
        let length = vertexIds.length;
        let adjacencyList = Array(length);
        for (var i = 0; i < length; i++) {
          adjacencyList[i] = Array();
          for (var j = 0; j < length; j++) {
            if (i === j) {
              continue;
            }
            if (this.hasEdge(vertexIds[i], vertexIds[j])) {
              adjacencyList[i].push(j);
            }
          }
        }
        return adjacencyList;
      }
      getBridges() {
        let length = this.vertices.length;
        let visited = new Array(length);
        let disc = new Array(length);
        let low = new Array(length);
        let parent = new Array(length);
        let adj = this.getAdjacencyList();
        let outBridges = Array();
        visited.fill(false);
        parent.fill(null);
        this._time = 0;
        for (var i = 0; i < length; i++) {
          if (!visited[i]) {
            this._bridgeDfs(i, visited, disc, low, parent, adj, outBridges);
          }
        }
        return outBridges;
      }
      traverseBF(startVertexId, callback) {
        let length = this.vertices.length;
        let visited = new Array(length);
        visited.fill(false);
        var queue = [startVertexId];
        while (queue.length > 0) {
          let u = queue.shift();
          let vertex = this.vertices[u];
          callback(vertex);
          for (var i = 0; i < vertex.neighbours.length; i++) {
            let v = vertex.neighbours[i];
            if (!visited[v]) {
              visited[v] = true;
              queue.push(v);
            }
          }
        }
      }
      getTreeDepth(vertexId, parentVertexId) {
        if (vertexId === null || parentVertexId === null) {
          return 0;
        }
        let neighbours = this.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);
        let max = 0;
        for (var i = 0; i < neighbours.length; i++) {
          let childId = neighbours[i];
          let d = this.getTreeDepth(childId, vertexId);
          if (d > max) {
            max = d;
          }
        }
        return max + 1;
      }
      traverseTree(vertexId, parentVertexId, callback, maxDepth = 999999, ignoreFirst = false, depth = 1, visited = null) {
        if (visited === null) {
          visited = new Uint8Array(this.vertices.length);
        }
        if (depth > maxDepth + 1 || visited[vertexId] === 1) {
          return;
        }
        visited[vertexId] = 1;
        let vertex = this.vertices[vertexId];
        let neighbours = vertex.getNeighbours(parentVertexId);
        if (!ignoreFirst || depth > 1) {
          callback(vertex);
        }
        for (var i = 0; i < neighbours.length; i++) {
          this.traverseTree(neighbours[i], vertexId, callback, maxDepth, ignoreFirst, depth + 1, visited);
        }
      }
      kkLayout(vertexIds, center, startVertexId, ring, bondLength, threshold = 0.1, innerThreshold = 0.1, maxIteration = 2e3, maxInnerIteration = 50, maxEnergy = 1e9) {
        let edgeStrength = bondLength;
        var i = vertexIds.length;
        while (i--) {
          let vertex = this.vertices[vertexIds[i]];
          var j = vertex.neighbours.length;
        }
        let matDist = this.getSubgraphDistanceMatrix(vertexIds);
        let length = vertexIds.length;
        let radius = MathHelper2.polyCircumradius(500, length);
        let angle = MathHelper2.centralAngle(length);
        let a = 0;
        let arrPositionX = new Float32Array(length);
        let arrPositionY = new Float32Array(length);
        let arrPositioned = Array(length);
        i = length;
        while (i--) {
          let vertex = this.vertices[vertexIds[i]];
          if (!vertex.positioned) {
            arrPositionX[i] = center.x + Math.cos(a) * radius;
            arrPositionY[i] = center.y + Math.sin(a) * radius;
          } else {
            arrPositionX[i] = vertex.position.x;
            arrPositionY[i] = vertex.position.y;
          }
          arrPositioned[i] = vertex.positioned;
          a += angle;
        }
        let matLength = Array(length);
        i = length;
        while (i--) {
          matLength[i] = new Array(length);
          var j = length;
          while (j--) {
            matLength[i][j] = bondLength * matDist[i][j];
          }
        }
        let matStrength = Array(length);
        i = length;
        while (i--) {
          matStrength[i] = Array(length);
          var j = length;
          while (j--) {
            matStrength[i][j] = edgeStrength * Math.pow(matDist[i][j], -2);
          }
        }
        let matEnergy = Array(length);
        let arrEnergySumX = new Float32Array(length);
        let arrEnergySumY = new Float32Array(length);
        i = length;
        while (i--) {
          matEnergy[i] = Array(length);
        }
        i = length;
        let ux, uy, dEx, dEy, vx, vy, denom;
        while (i--) {
          ux = arrPositionX[i];
          uy = arrPositionY[i];
          dEx = 0;
          dEy = 0;
          let j2 = length;
          while (j2--) {
            if (i === j2) {
              continue;
            }
            vx = arrPositionX[j2];
            vy = arrPositionY[j2];
            denom = 1 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));
            matEnergy[i][j2] = [
              matStrength[i][j2] * (ux - vx - matLength[i][j2] * (ux - vx) * denom),
              matStrength[i][j2] * (uy - vy - matLength[i][j2] * (uy - vy) * denom)
            ];
            matEnergy[j2][i] = matEnergy[i][j2];
            dEx += matEnergy[i][j2][0];
            dEy += matEnergy[i][j2][1];
          }
          arrEnergySumX[i] = dEx;
          arrEnergySumY[i] = dEy;
        }
        let energy = function(index) {
          return [arrEnergySumX[index] * arrEnergySumX[index] + arrEnergySumY[index] * arrEnergySumY[index], arrEnergySumX[index], arrEnergySumY[index]];
        };
        let highestEnergy = function() {
          let maxEnergy2 = 0;
          let maxEnergyId2 = 0;
          let maxDEX = 0;
          let maxDEY = 0;
          i = length;
          while (i--) {
            let [delta2, dEX2, dEY2] = energy(i);
            if (delta2 > maxEnergy2 && arrPositioned[i] === false) {
              maxEnergy2 = delta2;
              maxEnergyId2 = i;
              maxDEX = dEX2;
              maxDEY = dEY2;
            }
          }
          return [maxEnergyId2, maxEnergy2, maxDEX, maxDEY];
        };
        let update = function(index, dEX2, dEY2) {
          let dxx = 0;
          let dyy = 0;
          let dxy = 0;
          let ux2 = arrPositionX[index];
          let uy2 = arrPositionY[index];
          let arrL = matLength[index];
          let arrK = matStrength[index];
          i = length;
          while (i--) {
            if (i === index) {
              continue;
            }
            let vx3 = arrPositionX[i];
            let vy3 = arrPositionY[i];
            let l = arrL[i];
            let k = arrK[i];
            let m = (ux2 - vx3) * (ux2 - vx3);
            let denom3 = 1 / Math.pow(m + (uy2 - vy3) * (uy2 - vy3), 1.5);
            dxx += k * (1 - l * (uy2 - vy3) * (uy2 - vy3) * denom3);
            dyy += k * (1 - l * m * denom3);
            dxy += k * (l * (ux2 - vx3) * (uy2 - vy3) * denom3);
          }
          if (dxx === 0) {
            dxx = 0.1;
          }
          if (dyy === 0) {
            dyy = 0.1;
          }
          if (dxy === 0) {
            dxy = 0.1;
          }
          let dy = dEX2 / dxx + dEY2 / dxy;
          dy /= dxy / dxx - dyy / dxy;
          let dx = -(dxy * dy + dEX2) / dxx;
          arrPositionX[index] += dx;
          arrPositionY[index] += dy;
          let arrE = matEnergy[index];
          dEX2 = 0;
          dEY2 = 0;
          ux2 = arrPositionX[index];
          uy2 = arrPositionY[index];
          let vx2, vy2, prevEx, prevEy, denom2;
          i = length;
          while (i--) {
            if (index === i) {
              continue;
            }
            vx2 = arrPositionX[i];
            vy2 = arrPositionY[i];
            prevEx = arrE[i][0];
            prevEy = arrE[i][1];
            denom2 = 1 / Math.sqrt((ux2 - vx2) * (ux2 - vx2) + (uy2 - vy2) * (uy2 - vy2));
            dx = arrK[i] * (ux2 - vx2 - arrL[i] * (ux2 - vx2) * denom2);
            dy = arrK[i] * (uy2 - vy2 - arrL[i] * (uy2 - vy2) * denom2);
            arrE[i] = [dx, dy];
            dEX2 += dx;
            dEY2 += dy;
            arrEnergySumX[i] += dx - prevEx;
            arrEnergySumY[i] += dy - prevEy;
          }
          arrEnergySumX[index] = dEX2;
          arrEnergySumY[index] = dEY2;
        };
        let maxEnergyId = 0;
        let dEX = 0;
        let dEY = 0;
        let delta = 0;
        let iteration = 0;
        let innerIteration = 0;
        while (maxEnergy > threshold && maxIteration > iteration) {
          iteration++;
          [maxEnergyId, maxEnergy, dEX, dEY] = highestEnergy();
          delta = maxEnergy;
          innerIteration = 0;
          while (delta > innerThreshold && maxInnerIteration > innerIteration) {
            innerIteration++;
            update(maxEnergyId, dEX, dEY);
            [delta, dEX, dEY] = energy(maxEnergyId);
          }
        }
        i = length;
        while (i--) {
          let index = vertexIds[i];
          let vertex = this.vertices[index];
          vertex.position.x = arrPositionX[i];
          vertex.position.y = arrPositionY[i];
          vertex.positioned = true;
          vertex.forcePositioned = true;
        }
      }
      _bridgeDfs(u, visited, disc, low, parent, adj, outBridges) {
        visited[u] = true;
        disc[u] = low[u] = ++this._time;
        for (var i = 0; i < adj[u].length; i++) {
          let v = adj[u][i];
          if (!visited[v]) {
            parent[v] = u;
            this._bridgeDfs(v, visited, disc, low, parent, adj, outBridges);
            low[u] = Math.min(low[u], low[v]);
            if (low[v] > disc[u]) {
              outBridges.push([u, v]);
            }
          } else if (v !== parent[u]) {
            low[u] = Math.min(low[u], disc[v]);
          }
        }
      }
      static getConnectedComponents(adjacencyMatrix) {
        let length = adjacencyMatrix.length;
        let visited = new Array(length);
        let components = new Array();
        let count = 0;
        visited.fill(false);
        for (var u = 0; u < length; u++) {
          if (!visited[u]) {
            let component = Array();
            visited[u] = true;
            component.push(u);
            count++;
            Graph._ccGetDfs(u, visited, adjacencyMatrix, component);
            if (component.length > 1) {
              components.push(component);
            }
          }
        }
        return components;
      }
      static getConnectedComponentCount(adjacencyMatrix) {
        let length = adjacencyMatrix.length;
        let visited = new Array(length);
        let count = 0;
        visited.fill(false);
        for (var u = 0; u < length; u++) {
          if (!visited[u]) {
            visited[u] = true;
            count++;
            Graph._ccCountDfs(u, visited, adjacencyMatrix);
          }
        }
        return count;
      }
      static _ccCountDfs(u, visited, adjacencyMatrix) {
        for (var v = 0; v < adjacencyMatrix[u].length; v++) {
          let c = adjacencyMatrix[u][v];
          if (!c || visited[v] || u === v) {
            continue;
          }
          visited[v] = true;
          Graph._ccCountDfs(v, visited, adjacencyMatrix);
        }
      }
      static _ccGetDfs(u, visited, adjacencyMatrix, component) {
        for (var v = 0; v < adjacencyMatrix[u].length; v++) {
          let c = adjacencyMatrix[u][v];
          if (!c || visited[v] || u === v) {
            continue;
          }
          visited[v] = true;
          component.push(v);
          Graph._ccGetDfs(v, visited, adjacencyMatrix, component);
        }
      }
    };
    module2.exports = Graph;
  }
});

// node_modules/smiles-drawer/src/SSSR.js
var require_SSSR = __commonJS({
  "node_modules/smiles-drawer/src/SSSR.js"(exports, module2) {
    var Graph = require_Graph();
    var SSSR = class {
      static getRings(graph, experimental = false) {
        let adjacencyMatrix = graph.getComponentsAdjacencyMatrix();
        if (adjacencyMatrix.length === 0) {
          return null;
        }
        let connectedComponents = Graph.getConnectedComponents(adjacencyMatrix);
        let rings = Array();
        for (var i = 0; i < connectedComponents.length; i++) {
          let connectedComponent = connectedComponents[i];
          let ccAdjacencyMatrix = graph.getSubgraphAdjacencyMatrix([...connectedComponent]);
          let arrBondCount = new Uint16Array(ccAdjacencyMatrix.length);
          let arrRingCount = new Uint16Array(ccAdjacencyMatrix.length);
          for (var j = 0; j < ccAdjacencyMatrix.length; j++) {
            arrRingCount[j] = 0;
            arrBondCount[j] = 0;
            for (var k = 0; k < ccAdjacencyMatrix[j].length; k++) {
              arrBondCount[j] += ccAdjacencyMatrix[j][k];
            }
          }
          let nEdges = 0;
          for (var j = 0; j < ccAdjacencyMatrix.length; j++) {
            for (var k = j + 1; k < ccAdjacencyMatrix.length; k++) {
              nEdges += ccAdjacencyMatrix[j][k];
            }
          }
          let nSssr = nEdges - ccAdjacencyMatrix.length + 1;
          let allThree = true;
          for (var j = 0; j < arrBondCount.length; j++) {
            if (arrBondCount[j] !== 3) {
              allThree = false;
            }
          }
          if (allThree) {
            nSssr = 2 + nEdges - ccAdjacencyMatrix.length;
          }
          if (nSssr === 1) {
            rings.push([...connectedComponent]);
            continue;
          }
          if (experimental) {
            nSssr = 999;
          }
          let { d, pe, pe_prime } = SSSR.getPathIncludedDistanceMatrices(ccAdjacencyMatrix);
          let c = SSSR.getRingCandidates(d, pe, pe_prime);
          let sssr = SSSR.getSSSR(c, d, ccAdjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nSssr);
          for (var j = 0; j < sssr.length; j++) {
            let ring = Array(sssr[j].size);
            let index = 0;
            for (let val of sssr[j]) {
              ring[index++] = connectedComponent[val];
            }
            rings.push(ring);
          }
        }
        return rings;
      }
      static matrixToString(matrix) {
        let str = "";
        for (var i = 0; i < matrix.length; i++) {
          for (var j = 0; j < matrix[i].length; j++) {
            str += matrix[i][j] + " ";
          }
          str += "\n";
        }
        return str;
      }
      static getPathIncludedDistanceMatrices(adjacencyMatrix) {
        let length = adjacencyMatrix.length;
        let d = Array(length);
        let pe = Array(length);
        let pe_prime = Array(length);
        var l = 0;
        var m = 0;
        var n = 0;
        var i = length;
        while (i--) {
          d[i] = Array(length);
          pe[i] = Array(length);
          pe_prime[i] = Array(length);
          var j = length;
          while (j--) {
            d[i][j] = i === j || adjacencyMatrix[i][j] === 1 ? adjacencyMatrix[i][j] : Number.POSITIVE_INFINITY;
            if (d[i][j] === 1) {
              pe[i][j] = [[[i, j]]];
            } else {
              pe[i][j] = Array();
            }
            pe_prime[i][j] = Array();
          }
        }
        var k = length;
        var j;
        while (k--) {
          i = length;
          while (i--) {
            j = length;
            while (j--) {
              const previousPathLength = d[i][j];
              const newPathLength = d[i][k] + d[k][j];
              if (previousPathLength > newPathLength) {
                var l, m, n;
                if (previousPathLength === newPathLength + 1) {
                  pe_prime[i][j] = [pe[i][j].length];
                  l = pe[i][j].length;
                  while (l--) {
                    pe_prime[i][j][l] = [pe[i][j][l].length];
                    m = pe[i][j][l].length;
                    while (m--) {
                      pe_prime[i][j][l][m] = [pe[i][j][l][m].length];
                      n = pe[i][j][l][m].length;
                      while (n--) {
                        pe_prime[i][j][l][m][n] = [pe[i][j][l][m][0], pe[i][j][l][m][1]];
                      }
                    }
                  }
                } else {
                  pe_prime[i][j] = Array();
                }
                d[i][j] = newPathLength;
                pe[i][j] = [[]];
                l = pe[i][k][0].length;
                while (l--) {
                  pe[i][j][0].push(pe[i][k][0][l]);
                }
                l = pe[k][j][0].length;
                while (l--) {
                  pe[i][j][0].push(pe[k][j][0][l]);
                }
              } else if (previousPathLength === newPathLength) {
                if (pe[i][k].length && pe[k][j].length) {
                  var l;
                  if (pe[i][j].length) {
                    let tmp = Array();
                    l = pe[i][k][0].length;
                    while (l--) {
                      tmp.push(pe[i][k][0][l]);
                    }
                    l = pe[k][j][0].length;
                    while (l--) {
                      tmp.push(pe[k][j][0][l]);
                    }
                    pe[i][j].push(tmp);
                  } else {
                    let tmp = Array();
                    l = pe[i][k][0].length;
                    while (l--) {
                      tmp.push(pe[i][k][0][l]);
                    }
                    l = pe[k][j][0].length;
                    while (l--) {
                      tmp.push(pe[k][j][0][l]);
                    }
                    pe[i][j][0] = tmp;
                  }
                }
              } else if (previousPathLength === newPathLength - 1) {
                var l;
                if (pe_prime[i][j].length) {
                  let tmp = Array();
                  l = pe[i][k][0].length;
                  while (l--) {
                    tmp.push(pe[i][k][0][l]);
                  }
                  l = pe[k][j][0].length;
                  while (l--) {
                    tmp.push(pe[k][j][0][l]);
                  }
                  pe_prime[i][j].push(tmp);
                } else {
                  let tmp = Array();
                  l = pe[i][k][0].length;
                  while (l--) {
                    tmp.push(pe[i][k][0][l]);
                  }
                  l = pe[k][j][0].length;
                  while (l--) {
                    tmp.push(pe[k][j][0][l]);
                  }
                  pe_prime[i][j][0] = tmp;
                }
              }
            }
          }
        }
        return {
          d,
          pe,
          pe_prime
        };
      }
      static getRingCandidates(d, pe, pe_prime) {
        let length = d.length;
        let candidates = Array();
        let c = 0;
        for (let i = 0; i < length; i++) {
          for (let j = 0; j < length; j++) {
            if (d[i][j] === 0 || pe[i][j].length === 1 && pe_prime[i][j] === 0) {
              continue;
            } else {
              if (pe_prime[i][j].length !== 0) {
                c = 2 * (d[i][j] + 0.5);
              } else {
                c = 2 * d[i][j];
              }
              if (c !== Infinity) {
                candidates.push([c, pe[i][j], pe_prime[i][j]]);
              }
            }
          }
        }
        candidates.sort(function(a, b) {
          return a[0] - b[0];
        });
        return candidates;
      }
      static getSSSR(c, d, adjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nsssr) {
        let cSssr = Array();
        let allBonds = Array();
        for (let i = 0; i < c.length; i++) {
          if (c[i][0] % 2 !== 0) {
            for (let j = 0; j < c[i][2].length; j++) {
              let bonds = c[i][1][0].concat(c[i][2][j]);
              for (var k = 0; k < bonds.length; k++) {
                if (bonds[k][0].constructor === Array)
                  bonds[k] = bonds[k][0];
              }
              let atoms = SSSR.bondsToAtoms(bonds);
              if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {
                cSssr.push(atoms);
                allBonds = allBonds.concat(bonds);
              }
              if (cSssr.length > nsssr) {
                return cSssr;
              }
            }
          } else {
            for (let j = 0; j < c[i][1].length - 1; j++) {
              let bonds = c[i][1][j].concat(c[i][1][j + 1]);
              for (var k = 0; k < bonds.length; k++) {
                if (bonds[k][0].constructor === Array)
                  bonds[k] = bonds[k][0];
              }
              let atoms = SSSR.bondsToAtoms(bonds);
              if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {
                cSssr.push(atoms);
                allBonds = allBonds.concat(bonds);
              }
              if (cSssr.length > nsssr) {
                return cSssr;
              }
            }
          }
        }
        return cSssr;
      }
      static getEdgeCount(adjacencyMatrix) {
        let edgeCount = 0;
        let length = adjacencyMatrix.length;
        var i = length - 1;
        while (i--) {
          var j = length;
          while (j--) {
            if (adjacencyMatrix[i][j] === 1) {
              edgeCount++;
            }
          }
        }
        return edgeCount;
      }
      static getEdgeList(adjacencyMatrix) {
        let length = adjacencyMatrix.length;
        let edgeList = Array();
        var i = length - 1;
        while (i--) {
          var j = length;
          while (j--) {
            if (adjacencyMatrix[i][j] === 1) {
              edgeList.push([i, j]);
            }
          }
        }
        return edgeList;
      }
      static bondsToAtoms(bonds) {
        let atoms = new Set();
        var i = bonds.length;
        while (i--) {
          atoms.add(bonds[i][0]);
          atoms.add(bonds[i][1]);
        }
        return atoms;
      }
      static getBondCount(atoms, adjacencyMatrix) {
        let count = 0;
        for (let u of atoms) {
          for (let v of atoms) {
            if (u === v) {
              continue;
            }
            count += adjacencyMatrix[u][v];
          }
        }
        return count / 2;
      }
      static pathSetsContain(pathSets, pathSet, bonds, allBonds, arrBondCount, arrRingCount) {
        var i = pathSets.length;
        while (i--) {
          if (SSSR.isSupersetOf(pathSet, pathSets[i])) {
            return true;
          }
          if (pathSets[i].size !== pathSet.size) {
            continue;
          }
          if (SSSR.areSetsEqual(pathSets[i], pathSet)) {
            return true;
          }
        }
        let count = 0;
        let allContained = false;
        i = bonds.length;
        while (i--) {
          var j = allBonds.length;
          while (j--) {
            if (bonds[i][0] === allBonds[j][0] && bonds[i][1] === allBonds[j][1] || bonds[i][1] === allBonds[j][0] && bonds[i][0] === allBonds[j][1]) {
              count++;
            }
            if (count === bonds.length) {
              allContained = true;
            }
          }
        }
        let specialCase = false;
        if (allContained) {
          for (let element of pathSet) {
            if (arrRingCount[element] < arrBondCount[element]) {
              specialCase = true;
              break;
            }
          }
        }
        if (allContained && !specialCase) {
          return true;
        }
        for (let element of pathSet) {
          arrRingCount[element]++;
        }
        return false;
      }
      static areSetsEqual(setA, setB) {
        if (setA.size !== setB.size) {
          return false;
        }
        for (let element of setA) {
          if (!setB.has(element)) {
            return false;
          }
        }
        return true;
      }
      static isSupersetOf(setA, setB) {
        for (var element of setB) {
          if (!setA.has(element)) {
            return false;
          }
        }
        return true;
      }
    };
    module2.exports = SSSR;
  }
});

// node_modules/smiles-drawer/src/ThemeManager.js
var require_ThemeManager = __commonJS({
  "node_modules/smiles-drawer/src/ThemeManager.js"(exports, module2) {
    var ThemeManager = class {
      constructor(colors, theme) {
        this.colors = colors;
        this.theme = this.colors[theme];
      }
      getColor(key) {
        if (key) {
          key = key.toUpperCase();
          if (key in this.theme) {
            return this.theme[key];
          }
        }
        return this.theme["C"];
      }
      setTheme(theme) {
        if (this.colors.hasOwnProperty(theme)) {
          this.theme = this.colors[theme];
        }
      }
    };
    module2.exports = ThemeManager;
  }
});

// node_modules/smiles-drawer/src/Drawer.js
var require_Drawer = __commonJS({
  "node_modules/smiles-drawer/src/Drawer.js"(exports, module2) {
    var MathHelper2 = require_MathHelper();
    var ArrayHelper = require_ArrayHelper();
    var Vector2 = require_Vector2();
    var Line = require_Line();
    var Vertex = require_Vertex();
    var Edge = require_Edge();
    var Atom = require_Atom();
    var Ring = require_Ring();
    var RingConnection = require_RingConnection();
    var CanvasWrapper = require_CanvasWrapper();
    var Graph = require_Graph();
    var SSSR = require_SSSR();
    var ThemeManager = require_ThemeManager();
    var Drawer2 = class {
      constructor(options) {
        this.graph = null;
        this.doubleBondConfigCount = 0;
        this.doubleBondConfig = null;
        this.ringIdCounter = 0;
        this.ringConnectionIdCounter = 0;
        this.canvasWrapper = null;
        this.totalOverlapScore = 0;
        this.defaultOptions = {
          width: 500,
          height: 500,
          bondThickness: 0.6,
          bondLength: 15,
          shortBondLength: 0.85,
          bondSpacing: 0.18 * 15,
          atomVisualization: "default",
          isomeric: true,
          debug: false,
          terminalCarbons: false,
          explicitHydrogens: true,
          overlapSensitivity: 0.42,
          overlapResolutionIterations: 1,
          compactDrawing: true,
          fontSizeLarge: 5,
          fontSizeSmall: 3,
          padding: 20,
          experimentalSSSR: false,
          kkThreshold: 0.1,
          kkInnerThreshold: 0.1,
          kkMaxIteration: 2e4,
          kkMaxInnerIteration: 50,
          kkMaxEnergy: 1e9,
          themes: {
            dark: {
              C: "#fff",
              O: "#e74c3c",
              N: "#3498db",
              F: "#27ae60",
              CL: "#16a085",
              BR: "#d35400",
              I: "#8e44ad",
              P: "#d35400",
              S: "#f1c40f",
              B: "#e67e22",
              SI: "#e67e22",
              H: "#fff",
              BACKGROUND: "#141414"
            },
            light: {
              C: "#222",
              O: "#e74c3c",
              N: "#3498db",
              F: "#27ae60",
              CL: "#16a085",
              BR: "#d35400",
              I: "#8e44ad",
              P: "#d35400",
              S: "#f1c40f",
              B: "#e67e22",
              SI: "#e67e22",
              H: "#222",
              BACKGROUND: "#fff"
            }
          }
        };
        this.opts = this.extend(true, this.defaultOptions, options);
        this.opts.halfBondSpacing = this.opts.bondSpacing / 2;
        this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength;
        this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2;
        this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4;
        this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5;
        this.theme = this.opts.themes.dark;
      }
      extend() {
        let that = this;
        let extended = {};
        let deep = false;
        let i = 0;
        let length = arguments.length;
        if (Object.prototype.toString.call(arguments[0]) === "[object Boolean]") {
          deep = arguments[0];
          i++;
        }
        let merge = function(obj) {
          for (var prop in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
              if (deep && Object.prototype.toString.call(obj[prop]) === "[object Object]") {
                extended[prop] = that.extend(true, extended[prop], obj[prop]);
              } else {
                extended[prop] = obj[prop];
              }
            }
          }
        };
        for (; i < length; i++) {
          let obj = arguments[i];
          merge(obj);
        }
        return extended;
      }
      draw(data, target, themeName = "light", infoOnly = false) {
        this.initDraw(data, themeName, infoOnly);
        if (!this.infoOnly) {
          this.themeManager = new ThemeManager(this.opts.themes, themeName);
          this.canvasWrapper = new CanvasWrapper(target, this.themeManager, this.opts);
        }
        if (!infoOnly) {
          this.processGraph();
          this.canvasWrapper.scale(this.graph.vertices);
          this.drawEdges(this.opts.debug);
          this.drawVertices(this.opts.debug);
          this.canvasWrapper.reset();
          if (this.opts.debug) {
            console.log(this.graph);
            console.log(this.rings);
            console.log(this.ringConnections);
          }
        }
      }
      edgeRingCount(edgeId) {
        let edge = this.graph.edges[edgeId];
        let a = this.graph.vertices[edge.sourceId];
        let b = this.graph.vertices[edge.targetId];
        return Math.min(a.value.rings.length, b.value.rings.length);
      }
      getBridgedRings() {
        let bridgedRings = Array();
        for (var i = 0; i < this.rings.length; i++) {
          if (this.rings[i].isBridged) {
            bridgedRings.push(this.rings[i]);
          }
        }
        return bridgedRings;
      }
      getFusedRings() {
        let fusedRings = Array();
        for (var i = 0; i < this.rings.length; i++) {
          if (this.rings[i].isFused) {
            fusedRings.push(this.rings[i]);
          }
        }
        return fusedRings;
      }
      getSpiros() {
        let spiros = Array();
        for (var i = 0; i < this.rings.length; i++) {
          if (this.rings[i].isSpiro) {
            spiros.push(this.rings[i]);
          }
        }
        return spiros;
      }
      printRingInfo() {
        let result = "";
        for (var i = 0; i < this.rings.length; i++) {
          const ring = this.rings[i];
          result += ring.id + ";";
          result += ring.members.length + ";";
          result += ring.neighbours.length + ";";
          result += ring.isSpiro ? "true;" : "false;";
          result += ring.isFused ? "true;" : "false;";
          result += ring.isBridged ? "true;" : "false;";
          result += ring.rings.length + ";";
          result += "\n";
        }
        return result;
      }
      rotateDrawing() {
        let a = 0;
        let b = 0;
        let maxDist = 0;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let vertexA = this.graph.vertices[i];
          if (!vertexA.value.isDrawn) {
            continue;
          }
          for (var j = i + 1; j < this.graph.vertices.length; j++) {
            let vertexB = this.graph.vertices[j];
            if (!vertexB.value.isDrawn) {
              continue;
            }
            let dist = vertexA.position.distanceSq(vertexB.position);
            if (dist > maxDist) {
              maxDist = dist;
              a = i;
              b = j;
            }
          }
        }
        let angle = -Vector2.subtract(this.graph.vertices[a].position, this.graph.vertices[b].position).angle();
        if (!isNaN(angle)) {
          let remainder = angle % 0.523599;
          if (remainder < 0.2617995) {
            angle = angle - remainder;
          } else {
            angle += 0.523599 - remainder;
          }
          for (var i = 0; i < this.graph.vertices.length; i++) {
            if (i === b) {
              continue;
            }
            this.graph.vertices[i].position.rotateAround(angle, this.graph.vertices[b].position);
          }
          for (var i = 0; i < this.rings.length; i++) {
            this.rings[i].center.rotateAround(angle, this.graph.vertices[b].position);
          }
        }
      }
      getTotalOverlapScore() {
        return this.totalOverlapScore;
      }
      getRingCount() {
        return this.rings.length;
      }
      hasBridgedRing() {
        return this.bridgedRing;
      }
      getHeavyAtomCount() {
        let hac = 0;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          if (this.graph.vertices[i].value.element !== "H") {
            hac++;
          }
        }
        return hac;
      }
      getMolecularFormula() {
        let molecularFormula = "";
        let counts = new Map();
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let atom = this.graph.vertices[i].value;
          if (counts.has(atom.element)) {
            counts.set(atom.element, counts.get(atom.element) + 1);
          } else {
            counts.set(atom.element, 1);
          }
          if (atom.bracket && !atom.bracket.chirality) {
            if (counts.has("H")) {
              counts.set("H", counts.get("H") + atom.bracket.hcount);
            } else {
              counts.set("H", atom.bracket.hcount);
            }
          }
          if (!atom.bracket) {
            let nHydrogens = Atom.maxBonds[atom.element] - atom.bondCount;
            if (atom.isPartOfAromaticRing) {
              nHydrogens--;
            }
            if (counts.has("H")) {
              counts.set("H", counts.get("H") + nHydrogens);
            } else {
              counts.set("H", nHydrogens);
            }
          }
        }
        if (counts.has("C")) {
          let count = counts.get("C");
          molecularFormula += "C" + (count > 1 ? count : "");
          counts.delete("C");
        }
        if (counts.has("H")) {
          let count = counts.get("H");
          molecularFormula += "H" + (count > 1 ? count : "");
          counts.delete("H");
        }
        let elements = Object.keys(Atom.atomicNumbers).sort();
        elements.map((e) => {
          if (counts.has(e)) {
            let count = counts.get(e);
            molecularFormula += e + (count > 1 ? count : "");
          }
        });
        return molecularFormula;
      }
      getRingbondType(vertexA, vertexB) {
        if (vertexA.value.getRingbondCount() < 1 || vertexB.value.getRingbondCount() < 1) {
          return null;
        }
        for (var i = 0; i < vertexA.value.ringbonds.length; i++) {
          for (var j = 0; j < vertexB.value.ringbonds.length; j++) {
            if (vertexA.value.ringbonds[i].id === vertexB.value.ringbonds[j].id) {
              if (vertexA.value.ringbonds[i].bondType === "-") {
                return vertexB.value.ringbonds[j].bond;
              } else {
                return vertexA.value.ringbonds[i].bond;
              }
            }
          }
        }
        return null;
      }
      initDraw(data, themeName, infoOnly) {
        this.data = data;
        this.infoOnly = infoOnly;
        this.ringIdCounter = 0;
        this.ringConnectionIdCounter = 0;
        this.graph = new Graph(data, this.opts.isomeric);
        this.rings = Array();
        this.ringConnections = Array();
        this.originalRings = Array();
        this.originalRingConnections = Array();
        this.bridgedRing = false;
        this.doubleBondConfigCount = null;
        this.doubleBondConfig = null;
        this.initRings();
        this.initHydrogens();
      }
      processGraph() {
        this.position();
        this.restoreRingInformation();
        this.resolvePrimaryOverlaps();
        let overlapScore = this.getOverlapScore();
        this.totalOverlapScore = this.getOverlapScore().total;
        for (var o = 0; o < this.opts.overlapResolutionIterations; o++) {
          for (var i = 0; i < this.graph.edges.length; i++) {
            let edge = this.graph.edges[i];
            if (this.isEdgeRotatable(edge)) {
              let subTreeDepthA = this.graph.getTreeDepth(edge.sourceId, edge.targetId);
              let subTreeDepthB = this.graph.getTreeDepth(edge.targetId, edge.sourceId);
              let a = edge.targetId;
              let b = edge.sourceId;
              if (subTreeDepthA > subTreeDepthB) {
                a = edge.sourceId;
                b = edge.targetId;
              }
              let subTreeOverlap = this.getSubtreeOverlapScore(b, a, overlapScore.vertexScores);
              if (subTreeOverlap.value > this.opts.overlapSensitivity) {
                let vertexA = this.graph.vertices[a];
                let vertexB = this.graph.vertices[b];
                let neighboursB = vertexB.getNeighbours(a);
                if (neighboursB.length === 1) {
                  let neighbour = this.graph.vertices[neighboursB[0]];
                  let angle = neighbour.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper2.toRad(120));
                  this.rotateSubtree(neighbour.id, vertexB.id, angle, vertexB.position);
                  let newTotalOverlapScore = this.getOverlapScore().total;
                  if (newTotalOverlapScore > this.totalOverlapScore) {
                    this.rotateSubtree(neighbour.id, vertexB.id, -angle, vertexB.position);
                  } else {
                    this.totalOverlapScore = newTotalOverlapScore;
                  }
                } else if (neighboursB.length === 2) {
                  if (vertexB.value.rings.length !== 0 && vertexA.value.rings.length !== 0) {
                    continue;
                  }
                  let neighbourA = this.graph.vertices[neighboursB[0]];
                  let neighbourB = this.graph.vertices[neighboursB[1]];
                  if (neighbourA.value.rings.length === 1 && neighbourB.value.rings.length === 1) {
                    if (neighbourA.value.rings[0] !== neighbourB.value.rings[0]) {
                      continue;
                    }
                  } else if (neighbourA.value.rings.length !== 0 || neighbourB.value.rings.length !== 0) {
                    continue;
                  } else {
                    let angleA = neighbourA.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper2.toRad(120));
                    let angleB = neighbourB.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper2.toRad(120));
                    this.rotateSubtree(neighbourA.id, vertexB.id, angleA, vertexB.position);
                    this.rotateSubtree(neighbourB.id, vertexB.id, angleB, vertexB.position);
                    let newTotalOverlapScore = this.getOverlapScore().total;
                    if (newTotalOverlapScore > this.totalOverlapScore) {
                      this.rotateSubtree(neighbourA.id, vertexB.id, -angleA, vertexB.position);
                      this.rotateSubtree(neighbourB.id, vertexB.id, -angleB, vertexB.position);
                    } else {
                      this.totalOverlapScore = newTotalOverlapScore;
                    }
                  }
                }
                overlapScore = this.getOverlapScore();
              }
            }
          }
        }
        this.resolveSecondaryOverlaps(overlapScore.scores);
        if (this.opts.isomeric) {
          this.annotateStereochemistry();
        }
        if (this.opts.compactDrawing && this.opts.atomVisualization === "default") {
          this.initPseudoElements();
        }
        this.rotateDrawing();
      }
      initRings() {
        let openBonds = new Map();
        for (var i = this.graph.vertices.length - 1; i >= 0; i--) {
          let vertex = this.graph.vertices[i];
          if (vertex.value.ringbonds.length === 0) {
            continue;
          }
          for (var j = 0; j < vertex.value.ringbonds.length; j++) {
            let ringbondId = vertex.value.ringbonds[j].id;
            let ringbondBond = vertex.value.ringbonds[j].bond;
            if (!openBonds.has(ringbondId)) {
              openBonds.set(ringbondId, [vertex.id, ringbondBond]);
            } else {
              let sourceVertexId = vertex.id;
              let targetVertexId = openBonds.get(ringbondId)[0];
              let targetRingbondBond = openBonds.get(ringbondId)[1];
              let edge = new Edge(sourceVertexId, targetVertexId, 1);
              edge.setBondType(targetRingbondBond || ringbondBond || "-");
              let edgeId = this.graph.addEdge(edge);
              let targetVertex = this.graph.vertices[targetVertexId];
              vertex.addRingbondChild(targetVertexId, j);
              vertex.value.addNeighbouringElement(targetVertex.value.element);
              targetVertex.addRingbondChild(sourceVertexId, j);
              targetVertex.value.addNeighbouringElement(vertex.value.element);
              vertex.edges.push(edgeId);
              targetVertex.edges.push(edgeId);
              openBonds.delete(ringbondId);
            }
          }
        }
        let rings = SSSR.getRings(this.graph, this.opts.experimentalSSSR);
        if (rings === null) {
          return;
        }
        for (var i = 0; i < rings.length; i++) {
          let ringVertices = [...rings[i]];
          let ringId = this.addRing(new Ring(ringVertices));
          for (var j = 0; j < ringVertices.length; j++) {
            this.graph.vertices[ringVertices[j]].value.rings.push(ringId);
          }
        }
        for (var i = 0; i < this.rings.length - 1; i++) {
          for (var j = i + 1; j < this.rings.length; j++) {
            let a = this.rings[i];
            let b = this.rings[j];
            let ringConnection = new RingConnection(a, b);
            if (ringConnection.vertices.size > 0) {
              this.addRingConnection(ringConnection);
            }
          }
        }
        for (var i = 0; i < this.rings.length; i++) {
          let ring = this.rings[i];
          ring.neighbours = RingConnection.getNeighbours(this.ringConnections, ring.id);
        }
        for (var i = 0; i < this.rings.length; i++) {
          let ring = this.rings[i];
          this.graph.vertices[ring.members[0]].value.addAnchoredRing(ring.id);
        }
        this.backupRingInformation();
        while (this.rings.length > 0) {
          let id = -1;
          for (var i = 0; i < this.rings.length; i++) {
            let ring2 = this.rings[i];
            if (this.isPartOfBridgedRing(ring2.id) && !ring2.isBridged) {
              id = ring2.id;
            }
          }
          if (id === -1) {
            break;
          }
          let ring = this.getRing(id);
          let involvedRings = this.getBridgedRingRings(ring.id);
          this.bridgedRing = true;
          this.createBridgedRing(involvedRings, ring.members[0]);
          for (var i = 0; i < involvedRings.length; i++) {
            this.removeRing(involvedRings[i]);
          }
        }
      }
      initHydrogens() {
        if (!this.opts.explicitHydrogens) {
          for (var i = 0; i < this.graph.vertices.length; i++) {
            let vertex = this.graph.vertices[i];
            if (vertex.value.element !== "H") {
              continue;
            }
            let neighbour = this.graph.vertices[vertex.neighbours[0]];
            neighbour.value.hasHydrogen = true;
            if (!neighbour.value.isStereoCenter || neighbour.value.rings.length < 2 && !neighbour.value.bridgedRing || neighbour.value.bridgedRing && neighbour.value.originalRings.length < 2) {
              vertex.value.isDrawn = false;
            }
          }
        }
      }
      getBridgedRingRings(ringId) {
        let involvedRings = Array();
        let that = this;
        let recurse = function(r) {
          let ring = that.getRing(r);
          involvedRings.push(r);
          for (var i = 0; i < ring.neighbours.length; i++) {
            let n = ring.neighbours[i];
            if (involvedRings.indexOf(n) === -1 && n !== r && RingConnection.isBridge(that.ringConnections, that.graph.vertices, r, n)) {
              recurse(n);
            }
          }
        };
        recurse(ringId);
        return ArrayHelper.unique(involvedRings);
      }
      isPartOfBridgedRing(ringId) {
        for (var i = 0; i < this.ringConnections.length; i++) {
          if (this.ringConnections[i].containsRing(ringId) && this.ringConnections[i].isBridge(this.graph.vertices)) {
            return true;
          }
        }
        return false;
      }
      createBridgedRing(ringIds, sourceVertexId) {
        let ringMembers = new Set();
        let vertices = new Set();
        let neighbours = new Set();
        for (var i = 0; i < ringIds.length; i++) {
          let ring2 = this.getRing(ringIds[i]);
          ring2.isPartOfBridged = true;
          for (var j = 0; j < ring2.members.length; j++) {
            vertices.add(ring2.members[j]);
          }
          for (var j = 0; j < ring2.neighbours.length; j++) {
            let id = ring2.neighbours[j];
            if (ringIds.indexOf(id) === -1) {
              neighbours.add(ring2.neighbours[j]);
            }
          }
        }
        let leftovers = new Set();
        for (let id of vertices) {
          let vertex = this.graph.vertices[id];
          let intersection = ArrayHelper.intersection(ringIds, vertex.value.rings);
          if (vertex.value.rings.length === 1 || intersection.length === 1) {
            ringMembers.add(vertex.id);
          } else {
            leftovers.add(vertex.id);
          }
        }
        let tmp = Array();
        let insideRing = Array();
        for (let id of leftovers) {
          let vertex = this.graph.vertices[id];
          let onRing = false;
          for (let j2 = 0; j2 < vertex.edges.length; j2++) {
            if (this.edgeRingCount(vertex.edges[j2]) === 1) {
              onRing = true;
            }
          }
          if (onRing) {
            vertex.value.isBridgeNode = true;
            ringMembers.add(vertex.id);
          } else {
            vertex.value.isBridge = true;
            ringMembers.add(vertex.id);
          }
        }
        let ring = new Ring([...ringMembers]);
        this.addRing(ring);
        ring.isBridged = true;
        ring.neighbours = [...neighbours];
        for (var i = 0; i < ringIds.length; i++) {
          ring.rings.push(this.getRing(ringIds[i]).clone());
        }
        for (var i = 0; i < ring.members.length; i++) {
          this.graph.vertices[ring.members[i]].value.bridgedRing = ring.id;
        }
        for (var i = 0; i < insideRing.length; i++) {
          let vertex = this.graph.vertices[insideRing[i]];
          vertex.value.rings = Array();
        }
        for (let id of ringMembers) {
          let vertex = this.graph.vertices[id];
          vertex.value.rings = ArrayHelper.removeAll(vertex.value.rings, ringIds);
          vertex.value.rings.push(ring.id);
        }
        for (var i = 0; i < ringIds.length; i++) {
          for (var j = i + 1; j < ringIds.length; j++) {
            this.removeRingConnectionsBetween(ringIds[i], ringIds[j]);
          }
        }
        for (let id of neighbours) {
          let connections = this.getRingConnections(id, ringIds);
          for (var j = 0; j < connections.length; j++) {
            this.getRingConnection(connections[j]).updateOther(ring.id, id);
          }
          this.getRing(id).neighbours.push(ring.id);
        }
        return ring;
      }
      areVerticesInSameRing(vertexA, vertexB) {
        for (var i = 0; i < vertexA.value.rings.length; i++) {
          for (var j = 0; j < vertexB.value.rings.length; j++) {
            if (vertexA.value.rings[i] === vertexB.value.rings[j]) {
              return true;
            }
          }
        }
        return false;
      }
      getCommonRings(vertexA, vertexB) {
        let commonRings = Array();
        for (var i = 0; i < vertexA.value.rings.length; i++) {
          for (var j = 0; j < vertexB.value.rings.length; j++) {
            if (vertexA.value.rings[i] == vertexB.value.rings[j]) {
              commonRings.push(vertexA.value.rings[i]);
            }
          }
        }
        return commonRings;
      }
      getLargestOrAromaticCommonRing(vertexA, vertexB) {
        let commonRings = this.getCommonRings(vertexA, vertexB);
        let maxSize = 0;
        let largestCommonRing = null;
        for (var i = 0; i < commonRings.length; i++) {
          let ring = this.getRing(commonRings[i]);
          let size = ring.getSize();
          if (ring.isBenzeneLike(this.graph.vertices)) {
            return ring;
          } else if (size > maxSize) {
            maxSize = size;
            largestCommonRing = ring;
          }
        }
        return largestCommonRing;
      }
      getVerticesAt(position, radius, excludeVertexId) {
        let locals = Array();
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let vertex = this.graph.vertices[i];
          if (vertex.id === excludeVertexId || !vertex.positioned) {
            continue;
          }
          let distance = position.distanceSq(vertex.position);
          if (distance <= radius * radius) {
            locals.push(vertex.id);
          }
        }
        return locals;
      }
      getClosestVertex(vertex) {
        let minDist = 99999;
        let minVertex = null;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let v = this.graph.vertices[i];
          if (v.id === vertex.id) {
            continue;
          }
          let distSq = vertex.position.distanceSq(v.position);
          if (distSq < minDist) {
            minDist = distSq;
            minVertex = v;
          }
        }
        return minVertex;
      }
      addRing(ring) {
        ring.id = this.ringIdCounter++;
        this.rings.push(ring);
        return ring.id;
      }
      removeRing(ringId) {
        this.rings = this.rings.filter(function(item) {
          return item.id !== ringId;
        });
        this.ringConnections = this.ringConnections.filter(function(item) {
          return item.firstRingId !== ringId && item.secondRingId !== ringId;
        });
        for (var i = 0; i < this.rings.length; i++) {
          let r = this.rings[i];
          r.neighbours = r.neighbours.filter(function(item) {
            return item !== ringId;
          });
        }
      }
      getRing(ringId) {
        for (var i = 0; i < this.rings.length; i++) {
          if (this.rings[i].id == ringId) {
            return this.rings[i];
          }
        }
      }
      addRingConnection(ringConnection) {
        ringConnection.id = this.ringConnectionIdCounter++;
        this.ringConnections.push(ringConnection);
        return ringConnection.id;
      }
      removeRingConnection(ringConnectionId) {
        this.ringConnections = this.ringConnections.filter(function(item) {
          return item.id !== ringConnectionId;
        });
      }
      removeRingConnectionsBetween(vertexIdA, vertexIdB) {
        let toRemove = Array();
        for (var i = 0; i < this.ringConnections.length; i++) {
          let ringConnection = this.ringConnections[i];
          if (ringConnection.firstRingId === vertexIdA && ringConnection.secondRingId === vertexIdB || ringConnection.firstRingId === vertexIdB && ringConnection.secondRingId === vertexIdA) {
            toRemove.push(ringConnection.id);
          }
        }
        for (var i = 0; i < toRemove.length; i++) {
          this.removeRingConnection(toRemove[i]);
        }
      }
      getRingConnection(id) {
        for (var i = 0; i < this.ringConnections.length; i++) {
          if (this.ringConnections[i].id == id) {
            return this.ringConnections[i];
          }
        }
      }
      getRingConnections(ringId, ringIds) {
        let ringConnections = Array();
        for (var i = 0; i < this.ringConnections.length; i++) {
          let rc = this.ringConnections[i];
          for (var j = 0; j < ringIds.length; j++) {
            let id = ringIds[j];
            if (rc.firstRingId === ringId && rc.secondRingId === id || rc.firstRingId === id && rc.secondRingId === ringId) {
              ringConnections.push(rc.id);
            }
          }
        }
        return ringConnections;
      }
      getOverlapScore() {
        let total = 0;
        let overlapScores = new Float32Array(this.graph.vertices.length);
        for (var i = 0; i < this.graph.vertices.length; i++) {
          overlapScores[i] = 0;
        }
        for (var i = 0; i < this.graph.vertices.length; i++) {
          var j = this.graph.vertices.length;
          while (--j > i) {
            let a = this.graph.vertices[i];
            let b = this.graph.vertices[j];
            if (!a.value.isDrawn || !b.value.isDrawn) {
              continue;
            }
            let dist = Vector2.subtract(a.position, b.position).lengthSq();
            if (dist < this.opts.bondLengthSq) {
              let weighted = (this.opts.bondLength - Math.sqrt(dist)) / this.opts.bondLength;
              total += weighted;
              overlapScores[i] += weighted;
              overlapScores[j] += weighted;
            }
          }
        }
        let sortable = Array();
        for (var i = 0; i < this.graph.vertices.length; i++) {
          sortable.push({
            id: i,
            score: overlapScores[i]
          });
        }
        sortable.sort(function(a, b) {
          return b.score - a.score;
        });
        return {
          total,
          scores: sortable,
          vertexScores: overlapScores
        };
      }
      chooseSide(vertexA, vertexB, sides) {
        let an = vertexA.getNeighbours(vertexB.id);
        let bn = vertexB.getNeighbours(vertexA.id);
        let anCount = an.length;
        let bnCount = bn.length;
        let tn = ArrayHelper.merge(an, bn);
        let sideCount = [0, 0];
        for (var i = 0; i < tn.length; i++) {
          let v = this.graph.vertices[tn[i]].position;
          if (v.sameSideAs(vertexA.position, vertexB.position, sides[0])) {
            sideCount[0]++;
          } else {
            sideCount[1]++;
          }
        }
        let totalSideCount = [0, 0];
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let v = this.graph.vertices[i].position;
          if (v.sameSideAs(vertexA.position, vertexB.position, sides[0])) {
            totalSideCount[0]++;
          } else {
            totalSideCount[1]++;
          }
        }
        return {
          totalSideCount,
          totalPosition: totalSideCount[0] > totalSideCount[1] ? 0 : 1,
          sideCount,
          position: sideCount[0] > sideCount[1] ? 0 : 1,
          anCount,
          bnCount
        };
      }
      setRingCenter(ring) {
        let ringSize = ring.getSize();
        let total = new Vector2(0, 0);
        for (var i = 0; i < ringSize; i++) {
          total.add(this.graph.vertices[ring.members[i]].position);
        }
        ring.center = total.divide(ringSize);
      }
      getSubringCenter(ring, vertex) {
        let rings = vertex.value.originalRings;
        let center = ring.center;
        let smallest = Number.MAX_VALUE;
        for (var i = 0; i < rings.length; i++) {
          for (var j = 0; j < ring.rings.length; j++) {
            if (rings[i] === ring.rings[j].id) {
              if (ring.rings[j].getSize() < smallest) {
                center = ring.rings[j].center;
                smallest = ring.rings[j].getSize();
              }
            }
          }
        }
        return center;
      }
      drawEdges(debug) {
        let that = this;
        let drawn = Array(this.graph.edges.length);
        drawn.fill(false);
        this.graph.traverseBF(0, function(vertex) {
          let edges = that.graph.getEdges(vertex.id);
          for (var i2 = 0; i2 < edges.length; i2++) {
            let edgeId = edges[i2];
            if (!drawn[edgeId]) {
              drawn[edgeId] = true;
              that.drawEdge(edgeId, debug);
            }
          }
        });
        if (!this.bridgedRing) {
          for (var i = 0; i < this.rings.length; i++) {
            let ring = this.rings[i];
            if (this.isRingAromatic(ring)) {
              this.canvasWrapper.drawAromaticityRing(ring);
            }
          }
        }
      }
      drawEdge(edgeId, debug) {
        let that = this;
        let edge = this.graph.edges[edgeId];
        let vertexA = this.graph.vertices[edge.sourceId];
        let vertexB = this.graph.vertices[edge.targetId];
        let elementA = vertexA.value.element;
        let elementB = vertexB.value.element;
        if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && this.opts.atomVisualization === "default") {
          return;
        }
        let a = vertexA.position;
        let b = vertexB.position;
        let normals = this.getEdgeNormals(edge);
        let sides = ArrayHelper.clone(normals);
        sides[0].multiplyScalar(10).add(a);
        sides[1].multiplyScalar(10).add(a);
        if (edge.bondType === "=" || this.getRingbondType(vertexA, vertexB) === "=" || edge.isPartOfAromaticRing && this.bridgedRing) {
          let inRing = this.areVerticesInSameRing(vertexA, vertexB);
          let s = this.chooseSide(vertexA, vertexB, sides);
          if (inRing) {
            let lcr = this.getLargestOrAromaticCommonRing(vertexA, vertexB);
            let center = lcr.center;
            normals[0].multiplyScalar(that.opts.bondSpacing);
            normals[1].multiplyScalar(that.opts.bondSpacing);
            let line = null;
            if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {
              line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            } else {
              line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            }
            line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
            if (edge.isPartOfAromaticRing) {
              this.canvasWrapper.drawLine(line, true);
            } else {
              this.canvasWrapper.drawLine(line);
            }
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else if (edge.center || vertexA.isTerminal() && vertexB.isTerminal()) {
            normals[0].multiplyScalar(that.opts.halfBondSpacing);
            normals[1].multiplyScalar(that.opts.halfBondSpacing);
            let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            this.canvasWrapper.drawLine(lineA);
            this.canvasWrapper.drawLine(lineB);
          } else if (s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1) {
            normals[0].multiplyScalar(that.opts.halfBondSpacing);
            normals[1].multiplyScalar(that.opts.halfBondSpacing);
            let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            this.canvasWrapper.drawLine(lineA);
            this.canvasWrapper.drawLine(lineB);
          } else if (s.sideCount[0] > s.sideCount[1]) {
            normals[0].multiplyScalar(that.opts.bondSpacing);
            normals[1].multiplyScalar(that.opts.bondSpacing);
            let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
            this.canvasWrapper.drawLine(line);
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else if (s.sideCount[0] < s.sideCount[1]) {
            normals[0].multiplyScalar(that.opts.bondSpacing);
            normals[1].multiplyScalar(that.opts.bondSpacing);
            let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
            this.canvasWrapper.drawLine(line);
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else if (s.totalSideCount[0] > s.totalSideCount[1]) {
            normals[0].multiplyScalar(that.opts.bondSpacing);
            normals[1].multiplyScalar(that.opts.bondSpacing);
            let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
            this.canvasWrapper.drawLine(line);
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else if (s.totalSideCount[0] <= s.totalSideCount[1]) {
            normals[0].multiplyScalar(that.opts.bondSpacing);
            normals[1].multiplyScalar(that.opts.bondSpacing);
            let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
            this.canvasWrapper.drawLine(line);
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else {
          }
        } else if (edge.bondType === "#") {
          normals[0].multiplyScalar(that.opts.bondSpacing / 1.5);
          normals[1].multiplyScalar(that.opts.bondSpacing / 1.5);
          let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
          let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
          this.canvasWrapper.drawLine(lineA);
          this.canvasWrapper.drawLine(lineB);
          this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
        } else if (edge.bondType === ".") {
        } else {
          let isChiralCenterA = vertexA.value.isStereoCenter;
          let isChiralCenterB = vertexB.value.isStereoCenter;
          if (edge.wedge === "up") {
            this.canvasWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
          } else if (edge.wedge === "down") {
            this.canvasWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
          } else {
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
          }
        }
        if (debug) {
          let midpoint = Vector2.midpoint(a, b);
          this.canvasWrapper.drawDebugText(midpoint.x, midpoint.y, "e: " + edgeId);
        }
      }
      drawVertices(debug) {
        var i = this.graph.vertices.length;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let vertex = this.graph.vertices[i];
          let atom = vertex.value;
          let charge = 0;
          let isotope = 0;
          let bondCount = vertex.value.bondCount;
          let element = atom.element;
          let hydrogens = Atom.maxBonds[element] - bondCount;
          let dir = vertex.getTextDirection(this.graph.vertices);
          let isTerminal = this.opts.terminalCarbons || element !== "C" || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;
          let isCarbon = atom.element === "C";
          if (atom.element === "N" && atom.isPartOfAromaticRing) {
            hydrogens = 0;
          }
          if (atom.bracket) {
            hydrogens = atom.bracket.hcount;
            charge = atom.bracket.charge;
            isotope = atom.bracket.isotope;
          }
          if (this.opts.atomVisualization === "allballs") {
            this.canvasWrapper.drawBall(vertex.position.x, vertex.position.y, element);
          } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements) || this.graph.vertices.length === 1) {
            if (this.opts.atomVisualization === "default") {
              this.canvasWrapper.drawText(vertex.position.x, vertex.position.y, element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());
            } else if (this.opts.atomVisualization === "balls") {
              this.canvasWrapper.drawBall(vertex.position.x, vertex.position.y, element);
            }
          } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {
            let a = this.graph.vertices[vertex.neighbours[0]].position;
            let b = this.graph.vertices[vertex.neighbours[1]].position;
            let angle = Vector2.threePointangle(vertex.position, a, b);
            if (Math.abs(Math.PI - angle) < 0.1) {
              this.canvasWrapper.drawPoint(vertex.position.x, vertex.position.y, element);
            }
          }
          if (debug) {
            let value = "v: " + vertex.id + " " + ArrayHelper.print(atom.ringbonds);
            this.canvasWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);
          } else {
          }
        }
        if (this.opts.debug) {
          for (var i = 0; i < this.rings.length; i++) {
            let center = this.rings[i].center;
            this.canvasWrapper.drawDebugPoint(center.x, center.y, "r: " + this.rings[i].id);
          }
        }
      }
      position() {
        let startVertex = null;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          if (this.graph.vertices[i].value.bridgedRing !== null) {
            startVertex = this.graph.vertices[i];
            break;
          }
        }
        for (var i = 0; i < this.rings.length; i++) {
          if (this.rings[i].isBridged) {
            startVertex = this.graph.vertices[this.rings[i].members[0]];
          }
        }
        if (this.rings.length > 0 && startVertex === null) {
          startVertex = this.graph.vertices[this.rings[0].members[0]];
        }
        if (startVertex === null) {
          startVertex = this.graph.vertices[0];
        }
        this.createNextBond(startVertex, null, 0);
      }
      backupRingInformation() {
        this.originalRings = Array();
        this.originalRingConnections = Array();
        for (var i = 0; i < this.rings.length; i++) {
          this.originalRings.push(this.rings[i]);
        }
        for (var i = 0; i < this.ringConnections.length; i++) {
          this.originalRingConnections.push(this.ringConnections[i]);
        }
        for (var i = 0; i < this.graph.vertices.length; i++) {
          this.graph.vertices[i].value.backupRings();
        }
      }
      restoreRingInformation() {
        let bridgedRings = this.getBridgedRings();
        this.rings = Array();
        this.ringConnections = Array();
        for (var i = 0; i < bridgedRings.length; i++) {
          let bridgedRing = bridgedRings[i];
          for (var j = 0; j < bridgedRing.rings.length; j++) {
            let ring = bridgedRing.rings[j];
            this.originalRings[ring.id].center = ring.center;
          }
        }
        for (var i = 0; i < this.originalRings.length; i++) {
          this.rings.push(this.originalRings[i]);
        }
        for (var i = 0; i < this.originalRingConnections.length; i++) {
          this.ringConnections.push(this.originalRingConnections[i]);
        }
        for (var i = 0; i < this.graph.vertices.length; i++) {
          this.graph.vertices[i].value.restoreRings();
        }
      }
      createRing(ring, center = null, startVertex = null, previousVertex = null) {
        if (ring.positioned) {
          return;
        }
        center = center ? center : new Vector2(0, 0);
        let orderedNeighbours = ring.getOrderedNeighbours(this.ringConnections);
        let startingAngle = startVertex ? Vector2.subtract(startVertex.position, center).angle() : 0;
        let radius = MathHelper2.polyCircumradius(this.opts.bondLength, ring.getSize());
        let angle = MathHelper2.centralAngle(ring.getSize());
        ring.centralAngle = angle;
        let a = startingAngle;
        let that = this;
        let startVertexId = startVertex ? startVertex.id : null;
        if (ring.members.indexOf(startVertexId) === -1) {
          if (startVertex) {
            startVertex.positioned = false;
          }
          startVertexId = ring.members[0];
        }
        if (ring.isBridged) {
          this.graph.kkLayout(ring.members.slice(), center, startVertex.id, ring, this.opts.bondLength, this.opts.kkThreshold, this.opts.kkInnerThreshold, this.opts.kkMaxIteration, this.opts.kkMaxInnerIteration, this.opts.kkMaxEnergy);
          ring.positioned = true;
          this.setRingCenter(ring);
          center = ring.center;
          for (var i = 0; i < ring.rings.length; i++) {
            this.setRingCenter(ring.rings[i]);
          }
        } else {
          ring.eachMember(this.graph.vertices, function(v) {
            let vertex = that.graph.vertices[v];
            if (!vertex.positioned) {
              vertex.setPosition(center.x + Math.cos(a) * radius, center.y + Math.sin(a) * radius);
            }
            a += angle;
            if (!ring.isBridged || ring.rings.length < 3) {
              vertex.angle = a;
              vertex.positioned = true;
            }
          }, startVertexId, previousVertex ? previousVertex.id : null);
        }
        ring.positioned = true;
        ring.center = center;
        for (var i = 0; i < orderedNeighbours.length; i++) {
          let neighbour = this.getRing(orderedNeighbours[i].neighbour);
          if (neighbour.positioned) {
            continue;
          }
          let vertices = RingConnection.getVertices(this.ringConnections, ring.id, neighbour.id);
          if (vertices.length === 2) {
            ring.isFused = true;
            neighbour.isFused = true;
            let vertexA = this.graph.vertices[vertices[0]];
            let vertexB = this.graph.vertices[vertices[1]];
            let midpoint = Vector2.midpoint(vertexA.position, vertexB.position);
            let normals = Vector2.normals(vertexA.position, vertexB.position);
            normals[0].normalize();
            normals[1].normalize();
            let r = MathHelper2.polyCircumradius(this.opts.bondLength, neighbour.getSize());
            let apothem = MathHelper2.apothem(r, neighbour.getSize());
            normals[0].multiplyScalar(apothem).add(midpoint);
            normals[1].multiplyScalar(apothem).add(midpoint);
            let nextCenter = normals[0];
            if (Vector2.subtract(center, normals[1]).lengthSq() > Vector2.subtract(center, normals[0]).lengthSq()) {
              nextCenter = normals[1];
            }
            let posA = Vector2.subtract(vertexA.position, nextCenter);
            let posB = Vector2.subtract(vertexB.position, nextCenter);
            if (posA.clockwise(posB) === -1) {
              if (!neighbour.positioned) {
                this.createRing(neighbour, nextCenter, vertexA, vertexB);
              }
            } else {
              if (!neighbour.positioned) {
                this.createRing(neighbour, nextCenter, vertexB, vertexA);
              }
            }
          } else if (vertices.length === 1) {
            ring.isSpiro = true;
            neighbour.isSpiro = true;
            let vertexA = this.graph.vertices[vertices[0]];
            let nextCenter = Vector2.subtract(center, vertexA.position);
            nextCenter.invert();
            nextCenter.normalize();
            let r = MathHelper2.polyCircumradius(this.opts.bondLength, neighbour.getSize());
            nextCenter.multiplyScalar(r);
            nextCenter.add(vertexA.position);
            if (!neighbour.positioned) {
              this.createRing(neighbour, nextCenter, vertexA);
            }
          }
        }
        for (var i = 0; i < ring.members.length; i++) {
          let ringMember = this.graph.vertices[ring.members[i]];
          let ringMemberNeighbours = ringMember.neighbours;
          for (var j = 0; j < ringMemberNeighbours.length; j++) {
            let v = this.graph.vertices[ringMemberNeighbours[j]];
            if (v.positioned) {
              continue;
            }
            v.value.isConnectedToRing = true;
            this.createNextBond(v, ringMember, 0);
          }
        }
      }
      rotateSubtree(vertexId, parentVertexId, angle, center) {
        let that = this;
        this.graph.traverseTree(vertexId, parentVertexId, function(vertex) {
          vertex.position.rotateAround(angle, center);
          for (var i = 0; i < vertex.value.anchoredRings.length; i++) {
            let ring = that.rings[vertex.value.anchoredRings[i]];
            if (ring) {
              ring.center.rotateAround(angle, center);
            }
          }
        });
      }
      getSubtreeOverlapScore(vertexId, parentVertexId, vertexOverlapScores) {
        let that = this;
        let score = 0;
        let center = new Vector2(0, 0);
        let count = 0;
        this.graph.traverseTree(vertexId, parentVertexId, function(vertex) {
          if (!vertex.value.isDrawn) {
            return;
          }
          let s = vertexOverlapScores[vertex.id];
          if (s > that.opts.overlapSensitivity) {
            score += s;
            count++;
          }
          let position = that.graph.vertices[vertex.id].position.clone();
          position.multiplyScalar(s);
          center.add(position);
        });
        center.divide(score);
        return {
          value: score / count,
          center
        };
      }
      getCurrentCenterOfMass() {
        let total = new Vector2(0, 0);
        let count = 0;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let vertex = this.graph.vertices[i];
          if (vertex.positioned) {
            total.add(vertex.position);
            count++;
          }
        }
        return total.divide(count);
      }
      getCurrentCenterOfMassInNeigbourhood(vec, r = this.opts.bondLength * 2) {
        let total = new Vector2(0, 0);
        let count = 0;
        let rSq = r * r;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let vertex = this.graph.vertices[i];
          if (vertex.positioned && vec.distanceSq(vertex.position) < rSq) {
            total.add(vertex.position);
            count++;
          }
        }
        return total.divide(count);
      }
      resolvePrimaryOverlaps() {
        let overlaps = Array();
        let done = Array(this.graph.vertices.length);
        for (var i = 0; i < this.rings.length; i++) {
          let ring = this.rings[i];
          for (var j = 0; j < ring.members.length; j++) {
            let vertex = this.graph.vertices[ring.members[j]];
            if (done[vertex.id]) {
              continue;
            }
            done[vertex.id] = true;
            let nonRingNeighbours = this.getNonRingNeighbours(vertex.id);
            if (nonRingNeighbours.length > 1) {
              let rings = Array();
              for (var k = 0; k < vertex.value.rings.length; k++) {
                rings.push(vertex.value.rings[k]);
              }
              overlaps.push({
                common: vertex,
                rings,
                vertices: nonRingNeighbours
              });
            } else if (nonRingNeighbours.length === 1 && vertex.value.rings.length === 2) {
              let rings = Array();
              for (var k = 0; k < vertex.value.rings.length; k++) {
                rings.push(vertex.value.rings[k]);
              }
              overlaps.push({
                common: vertex,
                rings,
                vertices: nonRingNeighbours
              });
            }
          }
        }
        for (var i = 0; i < overlaps.length; i++) {
          let overlap = overlaps[i];
          if (overlap.vertices.length === 2) {
            let a = overlap.vertices[0];
            let b = overlap.vertices[1];
            if (!a.value.isDrawn || !b.value.isDrawn) {
              continue;
            }
            let angle = (2 * Math.PI - this.getRing(overlap.rings[0]).getAngle()) / 6;
            this.rotateSubtree(a.id, overlap.common.id, angle, overlap.common.position);
            this.rotateSubtree(b.id, overlap.common.id, -angle, overlap.common.position);
            let overlapScore = this.getOverlapScore();
            let subTreeOverlapA = this.getSubtreeOverlapScore(a.id, overlap.common.id, overlapScore.vertexScores);
            let subTreeOverlapB = this.getSubtreeOverlapScore(b.id, overlap.common.id, overlapScore.vertexScores);
            let total = subTreeOverlapA.value + subTreeOverlapB.value;
            this.rotateSubtree(a.id, overlap.common.id, -2 * angle, overlap.common.position);
            this.rotateSubtree(b.id, overlap.common.id, 2 * angle, overlap.common.position);
            overlapScore = this.getOverlapScore();
            subTreeOverlapA = this.getSubtreeOverlapScore(a.id, overlap.common.id, overlapScore.vertexScores);
            subTreeOverlapB = this.getSubtreeOverlapScore(b.id, overlap.common.id, overlapScore.vertexScores);
            if (subTreeOverlapA.value + subTreeOverlapB.value > total) {
              this.rotateSubtree(a.id, overlap.common.id, 2 * angle, overlap.common.position);
              this.rotateSubtree(b.id, overlap.common.id, -2 * angle, overlap.common.position);
            }
          } else if (overlap.vertices.length === 1) {
            if (overlap.rings.length === 2) {
            }
          }
        }
      }
      resolveSecondaryOverlaps(scores) {
        for (var i = 0; i < scores.length; i++) {
          if (scores[i].score > this.opts.overlapSensitivity) {
            let vertex = this.graph.vertices[scores[i].id];
            if (vertex.isTerminal()) {
              let closest = this.getClosestVertex(vertex);
              if (closest) {
                let closestPosition = null;
                if (closest.isTerminal()) {
                  closestPosition = closest.id === 0 ? this.graph.vertices[1].position : closest.previousPosition;
                } else {
                  closestPosition = closest.id === 0 ? this.graph.vertices[1].position : closest.position;
                }
                let vertexPreviousPosition = vertex.id === 0 ? this.graph.vertices[1].position : vertex.previousPosition;
                vertex.position.rotateAwayFrom(closestPosition, vertexPreviousPosition, MathHelper2.toRad(20));
              }
            }
          }
        }
      }
      getLastVertexWithAngle(vertexId) {
        let angle = 0;
        let vertex = null;
        while (!angle && vertexId) {
          vertex = this.graph.vertices[vertexId];
          angle = vertex.angle;
          vertexId = vertex.parentVertexId;
        }
        return vertex;
      }
      createNextBond(vertex, previousVertex = null, angle = 0, originShortest = false, skipPositioning = false) {
        if (vertex.positioned && !skipPositioning) {
          return;
        }
        let doubleBondConfigSet = false;
        if (previousVertex) {
          let edge = this.graph.getEdge(vertex.id, previousVertex.id);
          if ((edge.bondType === "/" || edge.bondType === "\\") && ++this.doubleBondConfigCount % 2 === 1) {
            if (this.doubleBondConfig === null) {
              this.doubleBondConfig = edge.bondType;
              doubleBondConfigSet = true;
              if (previousVertex.parentVertexId === null && vertex.value.branchBond) {
                if (this.doubleBondConfig === "/") {
                  this.doubleBondConfig = "\\";
                } else if (this.doubleBondConfig === "\\") {
                  this.doubleBondConfig = "/";
                }
              }
            }
          }
        }
        if (!skipPositioning) {
          if (!previousVertex) {
            let dummy = new Vector2(this.opts.bondLength, 0);
            dummy.rotate(MathHelper2.toRad(-60));
            vertex.previousPosition = dummy;
            vertex.setPosition(this.opts.bondLength, 0);
            vertex.angle = MathHelper2.toRad(-60);
            if (vertex.value.bridgedRing === null) {
              vertex.positioned = true;
            }
          } else if (previousVertex.value.rings.length > 0) {
            let neighbours = previousVertex.neighbours;
            let joinedVertex = null;
            let pos = new Vector2(0, 0);
            if (previousVertex.value.bridgedRing === null && previousVertex.value.rings.length > 1) {
              for (var i = 0; i < neighbours.length; i++) {
                let neighbour = this.graph.vertices[neighbours[i]];
                if (ArrayHelper.containsAll(neighbour.value.rings, previousVertex.value.rings)) {
                  joinedVertex = neighbour;
                  break;
                }
              }
            }
            if (joinedVertex === null) {
              for (var i = 0; i < neighbours.length; i++) {
                let v = this.graph.vertices[neighbours[i]];
                if (v.positioned && this.areVerticesInSameRing(v, previousVertex)) {
                  pos.add(Vector2.subtract(v.position, previousVertex.position));
                }
              }
              pos.invert().normalize().multiplyScalar(this.opts.bondLength).add(previousVertex.position);
            } else {
              pos = joinedVertex.position.clone().rotateAround(Math.PI, previousVertex.position);
            }
            vertex.previousPosition = previousVertex.position;
            vertex.setPositionFromVector(pos);
            vertex.positioned = true;
          } else {
            let v = new Vector2(this.opts.bondLength, 0);
            v.rotate(angle);
            v.add(previousVertex.position);
            vertex.setPositionFromVector(v);
            vertex.previousPosition = previousVertex.position;
            vertex.positioned = true;
          }
        }
        if (vertex.value.bridgedRing !== null) {
          let nextRing = this.getRing(vertex.value.bridgedRing);
          if (!nextRing.positioned) {
            let nextCenter = Vector2.subtract(vertex.previousPosition, vertex.position);
            nextCenter.invert();
            nextCenter.normalize();
            let r = MathHelper2.polyCircumradius(this.opts.bondLength, nextRing.members.length);
            nextCenter.multiplyScalar(r);
            nextCenter.add(vertex.position);
            this.createRing(nextRing, nextCenter, vertex);
          }
        } else if (vertex.value.rings.length > 0) {
          let nextRing = this.getRing(vertex.value.rings[0]);
          if (!nextRing.positioned) {
            let nextCenter = Vector2.subtract(vertex.previousPosition, vertex.position);
            nextCenter.invert();
            nextCenter.normalize();
            let r = MathHelper2.polyCircumradius(this.opts.bondLength, nextRing.getSize());
            nextCenter.multiplyScalar(r);
            nextCenter.add(vertex.position);
            this.createRing(nextRing, nextCenter, vertex);
          }
        } else {
          let isStereoCenter = vertex.value.isStereoCenter;
          let tmpNeighbours = vertex.getNeighbours();
          let neighbours = Array();
          for (var i = 0; i < tmpNeighbours.length; i++) {
            if (this.graph.vertices[tmpNeighbours[i]].value.isDrawn) {
              neighbours.push(tmpNeighbours[i]);
            }
          }
          if (previousVertex) {
            neighbours = ArrayHelper.remove(neighbours, previousVertex.id);
          }
          let previousAngle = vertex.getAngle();
          if (neighbours.length === 1) {
            let nextVertex = this.graph.vertices[neighbours[0]];
            if (vertex.value.bondType === "#" || previousVertex && previousVertex.value.bondType === "#" || vertex.value.bondType === "=" && previousVertex && previousVertex.value.rings.length === 0 && previousVertex.value.bondType === "=" && vertex.value.branchBond !== "-") {
              vertex.value.drawExplicit = false;
              if (previousVertex) {
                let straightEdge1 = this.graph.getEdge(vertex.id, previousVertex.id);
                straightEdge1.center = true;
              }
              let straightEdge2 = this.graph.getEdge(vertex.id, nextVertex.id);
              straightEdge2.center = true;
              if (vertex.value.bondType === "#" || previousVertex && previousVertex.value.bondType === "#") {
                nextVertex.angle = 0;
              }
              nextVertex.drawExplicit = true;
              this.createNextBond(nextVertex, vertex, previousAngle + nextVertex.angle);
            } else if (previousVertex && previousVertex.value.rings.length > 0) {
              let proposedAngleA = MathHelper2.toRad(60);
              let proposedAngleB = -proposedAngleA;
              let proposedVectorA = new Vector2(this.opts.bondLength, 0);
              let proposedVectorB = new Vector2(this.opts.bondLength, 0);
              proposedVectorA.rotate(proposedAngleA).add(vertex.position);
              proposedVectorB.rotate(proposedAngleB).add(vertex.position);
              let centerOfMass = this.getCurrentCenterOfMass();
              let distanceA = proposedVectorA.distanceSq(centerOfMass);
              let distanceB = proposedVectorB.distanceSq(centerOfMass);
              nextVertex.angle = distanceA < distanceB ? proposedAngleB : proposedAngleA;
              this.createNextBond(nextVertex, vertex, previousAngle + nextVertex.angle);
            } else {
              let a = vertex.angle;
              if (previousVertex && previousVertex.neighbours.length > 3) {
                if (a > 0) {
                  a = Math.min(1.0472, a);
                } else if (a < 0) {
                  a = Math.max(-1.0472, a);
                } else {
                  a = 1.0472;
                }
              } else if (!a) {
                let v = this.getLastVertexWithAngle(vertex.id);
                a = v.angle;
                if (!a) {
                  a = 1.0472;
                }
              }
              if (previousVertex && !doubleBondConfigSet) {
                let bondType = this.graph.getEdge(vertex.id, nextVertex.id).bondType;
                if (bondType === "/") {
                  if (this.doubleBondConfig === "/") {
                  } else if (this.doubleBondConfig === "\\") {
                    a = -a;
                  }
                  this.doubleBondConfig = null;
                } else if (bondType === "\\") {
                  if (this.doubleBondConfig === "/") {
                    a = -a;
                  } else if (this.doubleBondConfig === "\\") {
                  }
                  this.doubleBondConfig = null;
                }
              }
              if (originShortest) {
                nextVertex.angle = a;
              } else {
                nextVertex.angle = -a;
              }
              this.createNextBond(nextVertex, vertex, previousAngle + nextVertex.angle);
            }
          } else if (neighbours.length === 2) {
            let a = vertex.angle;
            if (!a) {
              a = 1.0472;
            }
            let subTreeDepthA = this.graph.getTreeDepth(neighbours[0], vertex.id);
            let subTreeDepthB = this.graph.getTreeDepth(neighbours[1], vertex.id);
            let l = this.graph.vertices[neighbours[0]];
            let r = this.graph.vertices[neighbours[1]];
            l.value.subtreeDepth = subTreeDepthA;
            r.value.subtreeDepth = subTreeDepthB;
            let subTreeDepthC = this.graph.getTreeDepth(previousVertex ? previousVertex.id : null, vertex.id);
            if (previousVertex) {
              previousVertex.value.subtreeDepth = subTreeDepthC;
            }
            let cis = 0;
            let trans = 1;
            if (r.value.element === "C" && l.value.element !== "C" && subTreeDepthB > 1 && subTreeDepthA < 5) {
              cis = 1;
              trans = 0;
            } else if (r.value.element !== "C" && l.value.element === "C" && subTreeDepthA > 1 && subTreeDepthB < 5) {
              cis = 0;
              trans = 1;
            } else if (subTreeDepthB > subTreeDepthA) {
              cis = 1;
              trans = 0;
            }
            let cisVertex = this.graph.vertices[neighbours[cis]];
            let transVertex = this.graph.vertices[neighbours[trans]];
            let edgeCis = this.graph.getEdge(vertex.id, cisVertex.id);
            let edgeTrans = this.graph.getEdge(vertex.id, transVertex.id);
            let originShortest2 = false;
            if (subTreeDepthC < subTreeDepthA && subTreeDepthC < subTreeDepthB) {
              originShortest2 = true;
            }
            transVertex.angle = a;
            cisVertex.angle = -a;
            if (this.doubleBondConfig === "\\") {
              if (transVertex.value.branchBond === "\\") {
                transVertex.angle = -a;
                cisVertex.angle = a;
              }
            } else if (this.doubleBondConfig === "/") {
              if (transVertex.value.branchBond === "/") {
                transVertex.angle = -a;
                cisVertex.angle = a;
              }
            }
            this.createNextBond(transVertex, vertex, previousAngle + transVertex.angle, originShortest2);
            this.createNextBond(cisVertex, vertex, previousAngle + cisVertex.angle, originShortest2);
          } else if (neighbours.length === 3) {
            let d1 = this.graph.getTreeDepth(neighbours[0], vertex.id);
            let d2 = this.graph.getTreeDepth(neighbours[1], vertex.id);
            let d3 = this.graph.getTreeDepth(neighbours[2], vertex.id);
            let s = this.graph.vertices[neighbours[0]];
            let l = this.graph.vertices[neighbours[1]];
            let r = this.graph.vertices[neighbours[2]];
            s.value.subtreeDepth = d1;
            l.value.subtreeDepth = d2;
            r.value.subtreeDepth = d3;
            if (d2 > d1 && d2 > d3) {
              s = this.graph.vertices[neighbours[1]];
              l = this.graph.vertices[neighbours[0]];
              r = this.graph.vertices[neighbours[2]];
            } else if (d3 > d1 && d3 > d2) {
              s = this.graph.vertices[neighbours[2]];
              l = this.graph.vertices[neighbours[0]];
              r = this.graph.vertices[neighbours[1]];
            }
            if (previousVertex && previousVertex.value.rings.length < 1 && s.value.rings.length < 1 && l.value.rings.length < 1 && r.value.rings.length < 1 && this.graph.getTreeDepth(l.id, vertex.id) === 1 && this.graph.getTreeDepth(r.id, vertex.id) === 1 && this.graph.getTreeDepth(s.id, vertex.id) > 1) {
              s.angle = -vertex.angle;
              if (vertex.angle >= 0) {
                l.angle = MathHelper2.toRad(30);
                r.angle = MathHelper2.toRad(90);
              } else {
                l.angle = -MathHelper2.toRad(30);
                r.angle = -MathHelper2.toRad(90);
              }
              this.createNextBond(s, vertex, previousAngle + s.angle);
              this.createNextBond(l, vertex, previousAngle + l.angle);
              this.createNextBond(r, vertex, previousAngle + r.angle);
            } else {
              s.angle = 0;
              l.angle = MathHelper2.toRad(90);
              r.angle = -MathHelper2.toRad(90);
              this.createNextBond(s, vertex, previousAngle + s.angle);
              this.createNextBond(l, vertex, previousAngle + l.angle);
              this.createNextBond(r, vertex, previousAngle + r.angle);
            }
          } else if (neighbours.length === 4) {
            let d1 = this.graph.getTreeDepth(neighbours[0], vertex.id);
            let d2 = this.graph.getTreeDepth(neighbours[1], vertex.id);
            let d3 = this.graph.getTreeDepth(neighbours[2], vertex.id);
            let d4 = this.graph.getTreeDepth(neighbours[3], vertex.id);
            let w = this.graph.vertices[neighbours[0]];
            let x = this.graph.vertices[neighbours[1]];
            let y = this.graph.vertices[neighbours[2]];
            let z = this.graph.vertices[neighbours[3]];
            w.value.subtreeDepth = d1;
            x.value.subtreeDepth = d2;
            y.value.subtreeDepth = d3;
            z.value.subtreeDepth = d4;
            if (d2 > d1 && d2 > d3 && d2 > d4) {
              w = this.graph.vertices[neighbours[1]];
              x = this.graph.vertices[neighbours[0]];
              y = this.graph.vertices[neighbours[2]];
              z = this.graph.vertices[neighbours[3]];
            } else if (d3 > d1 && d3 > d2 && d3 > d4) {
              w = this.graph.vertices[neighbours[2]];
              x = this.graph.vertices[neighbours[0]];
              y = this.graph.vertices[neighbours[1]];
              z = this.graph.vertices[neighbours[3]];
            } else if (d4 > d1 && d4 > d2 && d4 > d3) {
              w = this.graph.vertices[neighbours[3]];
              x = this.graph.vertices[neighbours[0]];
              y = this.graph.vertices[neighbours[1]];
              z = this.graph.vertices[neighbours[2]];
            }
            w.angle = -MathHelper2.toRad(36);
            x.angle = MathHelper2.toRad(36);
            y.angle = -MathHelper2.toRad(108);
            z.angle = MathHelper2.toRad(108);
            this.createNextBond(w, vertex, previousAngle + w.angle);
            this.createNextBond(x, vertex, previousAngle + x.angle);
            this.createNextBond(y, vertex, previousAngle + y.angle);
            this.createNextBond(z, vertex, previousAngle + z.angle);
          }
        }
      }
      getCommonRingbondNeighbour(vertex) {
        let neighbours = vertex.neighbours;
        for (var i = 0; i < neighbours.length; i++) {
          let neighbour = this.graph.vertices[neighbours[i]];
          if (ArrayHelper.containsAll(neighbour.value.rings, vertex.value.rings)) {
            return neighbour;
          }
        }
        return null;
      }
      isPointInRing(vec) {
        for (var i = 0; i < this.rings.length; i++) {
          let ring = this.rings[i];
          if (!ring.positioned) {
            continue;
          }
          let radius = MathHelper2.polyCircumradius(this.opts.bondLength, ring.getSize());
          let radiusSq = radius * radius;
          if (vec.distanceSq(ring.center) < radiusSq) {
            return true;
          }
        }
        return false;
      }
      isEdgeInRing(edge) {
        let source = this.graph.vertices[edge.sourceId];
        let target = this.graph.vertices[edge.targetId];
        return this.areVerticesInSameRing(source, target);
      }
      isEdgeRotatable(edge) {
        let vertexA = this.graph.vertices[edge.sourceId];
        let vertexB = this.graph.vertices[edge.targetId];
        if (edge.bondType !== "-") {
          return false;
        }
        if (vertexA.isTerminal() || vertexB.isTerminal()) {
          return false;
        }
        if (vertexA.value.rings.length > 0 && vertexB.value.rings.length > 0 && this.areVerticesInSameRing(vertexA, vertexB)) {
          return false;
        }
        return true;
      }
      isRingAromatic(ring) {
        for (var i = 0; i < ring.members.length; i++) {
          let vertex = this.graph.vertices[ring.members[i]];
          if (!vertex.value.isPartOfAromaticRing) {
            return false;
          }
        }
        return true;
      }
      getEdgeNormals(edge) {
        let v1 = this.graph.vertices[edge.sourceId].position;
        let v2 = this.graph.vertices[edge.targetId].position;
        let normals = Vector2.units(v1, v2);
        return normals;
      }
      getNonRingNeighbours(vertexId) {
        let nrneighbours = Array();
        let vertex = this.graph.vertices[vertexId];
        let neighbours = vertex.neighbours;
        for (var i = 0; i < neighbours.length; i++) {
          let neighbour = this.graph.vertices[neighbours[i]];
          let nIntersections = ArrayHelper.intersection(vertex.value.rings, neighbour.value.rings).length;
          if (nIntersections === 0 && neighbour.value.isBridge == false) {
            nrneighbours.push(neighbour);
          }
        }
        return nrneighbours;
      }
      annotateStereochemistry() {
        let maxDepth = 10;
        for (var i = 0; i < this.graph.vertices.length; i++) {
          let vertex = this.graph.vertices[i];
          if (!vertex.value.isStereoCenter) {
            continue;
          }
          let neighbours = vertex.getNeighbours();
          let nNeighbours = neighbours.length;
          let priorities = Array(nNeighbours);
          for (var j = 0; j < nNeighbours; j++) {
            let visited = new Uint8Array(this.graph.vertices.length);
            let priority = Array(Array());
            visited[vertex.id] = 1;
            this.visitStereochemistry(neighbours[j], vertex.id, visited, priority, maxDepth, 0);
            for (var k = 0; k < priority.length; k++) {
              priority[k].sort(function(a, b) {
                return b - a;
              });
            }
            priorities[j] = [j, priority];
          }
          let maxLevels = 0;
          let maxEntries = 0;
          for (var j = 0; j < priorities.length; j++) {
            if (priorities[j][1].length > maxLevels) {
              maxLevels = priorities[j][1].length;
            }
            for (var k = 0; k < priorities[j][1].length; k++) {
              if (priorities[j][1][k].length > maxEntries) {
                maxEntries = priorities[j][1][k].length;
              }
            }
          }
          for (var j = 0; j < priorities.length; j++) {
            let diff = maxLevels - priorities[j][1].length;
            for (var k = 0; k < diff; k++) {
              priorities[j][1].push([]);
            }
            priorities[j][1].push([neighbours[j]]);
            for (var k = 0; k < priorities[j][1].length; k++) {
              let diff2 = maxEntries - priorities[j][1][k].length;
              for (var l = 0; l < diff2; l++) {
                priorities[j][1][k].push(0);
              }
            }
          }
          priorities.sort(function(a, b) {
            for (var j2 = 0; j2 < a[1].length; j2++) {
              for (var k2 = 0; k2 < a[1][j2].length; k2++) {
                if (a[1][j2][k2] > b[1][j2][k2]) {
                  return -1;
                } else if (a[1][j2][k2] < b[1][j2][k2]) {
                  return 1;
                }
              }
            }
            return 0;
          });
          let order = new Uint8Array(nNeighbours);
          for (var j = 0; j < nNeighbours; j++) {
            order[j] = priorities[j][0];
            vertex.value.priority = j;
          }
          let posA = this.graph.vertices[neighbours[order[0]]].position;
          let posB = this.graph.vertices[neighbours[order[1]]].position;
          let posC = this.graph.vertices[neighbours[order[2]]].position;
          let cwA = posA.relativeClockwise(posB, vertex.position);
          let cwB = posA.relativeClockwise(posC, vertex.position);
          let isCw = cwA === -1;
          let rotation = vertex.value.bracket.chirality === "@" ? -1 : 1;
          let rs = MathHelper2.parityOfPermutation(order) * rotation === 1 ? "R" : "S";
          let wedgeA = "down";
          let wedgeB = "up";
          if (isCw && rs !== "R" || !isCw && rs !== "S") {
            vertex.value.hydrogenDirection = "up";
            wedgeA = "up";
            wedgeB = "down";
          }
          if (vertex.value.hasHydrogen) {
            this.graph.getEdge(vertex.id, neighbours[order[order.length - 1]]).wedge = wedgeA;
          }
          let wedgeOrder = new Array(neighbours.length - 1);
          let showHydrogen = vertex.value.rings.length > 1 && vertex.value.hasHydrogen;
          let offset = vertex.value.hasHydrogen ? 1 : 0;
          for (var j = 0; j < order.length - offset; j++) {
            wedgeOrder[j] = new Uint32Array(2);
            let neighbour = this.graph.vertices[neighbours[order[j]]];
            wedgeOrder[j][0] += neighbour.value.isStereoCenter ? 0 : 1e5;
            wedgeOrder[j][0] += this.areVerticesInSameRing(neighbour, vertex) ? 0 : 1e4;
            wedgeOrder[j][0] += neighbour.value.isHeteroAtom() ? 1e3 : 0;
            wedgeOrder[j][0] -= neighbour.value.subtreeDepth === 0 ? 1e3 : 0;
            wedgeOrder[j][0] += 1e3 - neighbour.value.subtreeDepth;
            wedgeOrder[j][1] = neighbours[order[j]];
          }
          wedgeOrder.sort(function(a, b) {
            if (a[0] > b[0]) {
              return -1;
            } else if (a[0] < b[0]) {
              return 1;
            }
            return 0;
          });
          if (!showHydrogen) {
            let wedgeId = wedgeOrder[0][1];
            if (vertex.value.hasHydrogen) {
              this.graph.getEdge(vertex.id, wedgeId).wedge = wedgeB;
            } else {
              let wedge = wedgeB;
              for (var j = order.length - 1; j >= 0; j--) {
                if (wedge === wedgeA) {
                  wedge = wedgeB;
                } else {
                  wedge = wedgeA;
                }
                if (neighbours[order[j]] === wedgeId) {
                  break;
                }
              }
              this.graph.getEdge(vertex.id, wedgeId).wedge = wedge;
            }
          }
          vertex.value.chirality = rs;
        }
      }
      visitStereochemistry(vertexId, previousVertexId, visited, priority, maxDepth, depth, parentAtomicNumber = 0) {
        visited[vertexId] = 1;
        let vertex = this.graph.vertices[vertexId];
        let atomicNumber = vertex.value.getAtomicNumber();
        if (priority.length <= depth) {
          priority.push(Array());
        }
        for (var i = 0; i < this.graph.getEdge(vertexId, previousVertexId).weight; i++) {
          priority[depth].push(parentAtomicNumber * 1e3 + atomicNumber);
        }
        let neighbours = this.graph.vertices[vertexId].neighbours;
        for (var i = 0; i < neighbours.length; i++) {
          if (visited[neighbours[i]] !== 1 && depth < maxDepth - 1) {
            this.visitStereochemistry(neighbours[i], vertexId, visited.slice(), priority, maxDepth, depth + 1, atomicNumber);
          }
        }
        if (depth < maxDepth - 1) {
          let bonds = 0;
          for (var i = 0; i < neighbours.length; i++) {
            bonds += this.graph.getEdge(vertexId, neighbours[i]).weight;
          }
          for (var i = 0; i < vertex.value.getMaxBonds() - bonds; i++) {
            if (priority.length <= depth + 1) {
              priority.push(Array());
            }
            priority[depth + 1].push(atomicNumber * 1e3 + 1);
          }
        }
      }
      initPseudoElements() {
        for (var i = 0; i < this.graph.vertices.length; i++) {
          const vertex = this.graph.vertices[i];
          const neighbourIds = vertex.neighbours;
          let neighbours = Array(neighbourIds.length);
          for (var j = 0; j < neighbourIds.length; j++) {
            neighbours[j] = this.graph.vertices[neighbourIds[j]];
          }
          if (vertex.getNeighbourCount() < 3 || vertex.value.rings.length > 0) {
            continue;
          }
          if (vertex.value.element === "P") {
            continue;
          }
          if (vertex.value.element === "C" && neighbours.length === 3 && neighbours[0].value.element === "N" && neighbours[1].value.element === "N" && neighbours[2].value.element === "N") {
            continue;
          }
          let heteroAtomCount = 0;
          let ctn = 0;
          for (var j = 0; j < neighbours.length; j++) {
            let neighbour = neighbours[j];
            let neighbouringElement = neighbour.value.element;
            let neighbourCount = neighbour.getNeighbourCount();
            if (neighbouringElement !== "C" && neighbouringElement !== "H" && neighbourCount === 1) {
              heteroAtomCount++;
            }
            if (neighbourCount > 1) {
              ctn++;
            }
          }
          if (ctn > 1 || heteroAtomCount < 2) {
            continue;
          }
          let previous = null;
          for (var j = 0; j < neighbours.length; j++) {
            let neighbour = neighbours[j];
            if (neighbour.getNeighbourCount() > 1) {
              previous = neighbour;
            }
          }
          for (var j = 0; j < neighbours.length; j++) {
            let neighbour = neighbours[j];
            if (neighbour.getNeighbourCount() > 1) {
              continue;
            }
            neighbour.value.isDrawn = false;
            let hydrogens = Atom.maxBonds[neighbour.value.element] - neighbour.value.bondCount;
            let charge = "";
            if (neighbour.value.bracket) {
              hydrogens = neighbour.value.bracket.hcount;
              charge = neighbour.value.bracket.charge || 0;
            }
            vertex.value.attachPseudoElement(neighbour.value.element, previous ? previous.value.element : null, hydrogens, charge);
          }
        }
        for (var i = 0; i < this.graph.vertices.length; i++) {
          const vertex = this.graph.vertices[i];
          const atom = vertex.value;
          const element = atom.element;
          if (element === "C" || element === "H" || !atom.isDrawn) {
            continue;
          }
          const neighbourIds = vertex.neighbours;
          let neighbours = Array(neighbourIds.length);
          for (var j = 0; j < neighbourIds.length; j++) {
            neighbours[j] = this.graph.vertices[neighbourIds[j]];
          }
          for (var j = 0; j < neighbours.length; j++) {
            let neighbour = neighbours[j].value;
            if (!neighbour.hasAttachedPseudoElements || neighbour.getAttachedPseudoElementsCount() !== 2) {
              continue;
            }
            const pseudoElements = neighbour.getAttachedPseudoElements();
            if (pseudoElements.hasOwnProperty("0O") && pseudoElements.hasOwnProperty("3C")) {
              neighbour.isDrawn = false;
              vertex.value.attachPseudoElement("Ac", "", 0);
            }
          }
        }
      }
    };
    module2.exports = Drawer2;
  }
});

// node_modules/smiles-drawer/src/Parser.js
var require_Parser = __commonJS({
  "node_modules/smiles-drawer/src/Parser.js"(exports, module2) {
    module2.exports = function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      peg$SyntaxError.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          "class": function(expectation) {
            var escapedParts = "", i;
            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
            }
            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },
          any: function(expectation) {
            return "any character";
          },
          end: function(expectation) {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
          return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
          });
        }
        function classEscape(s) {
          return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = new Array(expected2.length), i, j;
          for (i = 0; i < expected2.length; i++) {
            descriptions[i] = describeExpectation(expected2[i]);
          }
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};
        var nOpenParentheses = input.split("(").length - 1;
        var nCloseParentheses = input.split(")").length - 1;
        if (nOpenParentheses !== nCloseParentheses) {
          throw peg$buildSimpleError("The number of opening parentheses does not match the number of closing parentheses.", 0);
        }
        var peg$FAILED = {}, peg$startRuleFunctions = {
          chain: peg$parsechain
        }, peg$startRuleFunction = peg$parsechain, peg$c0 = function(s) {
          var branches = [];
          var rings = [];
          for (var i = 0; i < s[1].length; i++) {
            branches.push(s[1][i]);
          }
          for (var i = 0; i < s[2].length; i++) {
            var bond = s[2][i][0] ? s[2][i][0] : "-";
            rings.push({
              "bond": bond,
              "id": s[2][i][1]
            });
          }
          for (var i = 0; i < s[3].length; i++) {
            branches.push(s[3][i]);
          }
          for (var i = 0; i < s[6].length; i++) {
            branches.push(s[6][i]);
          }
          return {
            "atom": s[0],
            "isBracket": s[0].element ? true : false,
            "branches": branches,
            "branchCount": branches.length,
            "ringbonds": rings,
            "ringbondCount": rings.length,
            "bond": s[4] ? s[4] : "-",
            "next": s[5],
            "hasNext": s[5] ? true : false
          };
          return s;
        }, peg$c1 = "(", peg$c2 = peg$literalExpectation("(", false), peg$c3 = ")", peg$c4 = peg$literalExpectation(")", false), peg$c5 = function(b) {
          var bond = b[1] ? b[1] : "-";
          b[2].branchBond = bond;
          return b[2];
        }, peg$c6 = function(a) {
          return a;
        }, peg$c7 = /^[\-=#$:\/\\.]/, peg$c8 = peg$classExpectation(["-", "=", "#", "$", ":", "/", "\\", "."], false, false), peg$c9 = function(b) {
          return b;
        }, peg$c10 = "[", peg$c11 = peg$literalExpectation("[", false), peg$c12 = "se", peg$c13 = peg$literalExpectation("se", false), peg$c14 = "as", peg$c15 = peg$literalExpectation("as", false), peg$c16 = "]", peg$c17 = peg$literalExpectation("]", false), peg$c18 = function(b) {
          return {
            "isotope": b[1],
            "element": b[2],
            "chirality": b[3],
            "hcount": b[4],
            "charge": b[5],
            "class": b[6]
          };
        }, peg$c19 = "B", peg$c20 = peg$literalExpectation("B", false), peg$c21 = "r", peg$c22 = peg$literalExpectation("r", false), peg$c23 = "C", peg$c24 = peg$literalExpectation("C", false), peg$c25 = "l", peg$c26 = peg$literalExpectation("l", false), peg$c27 = /^[NOPSFI]/, peg$c28 = peg$classExpectation(["N", "O", "P", "S", "F", "I"], false, false), peg$c29 = function(o) {
          if (o.length > 1)
            return o.join("");
          return o;
        }, peg$c30 = /^[bcnops]/, peg$c31 = peg$classExpectation(["b", "c", "n", "o", "p", "s"], false, false), peg$c32 = "*", peg$c33 = peg$literalExpectation("*", false), peg$c34 = function(w) {
          return w;
        }, peg$c35 = /^[A-Z]/, peg$c36 = peg$classExpectation([
          ["A", "Z"]
        ], false, false), peg$c37 = /^[a-z]/, peg$c38 = peg$classExpectation([
          ["a", "z"]
        ], false, false), peg$c39 = function(e) {
          return e.join("");
        }, peg$c40 = "%", peg$c41 = peg$literalExpectation("%", false), peg$c42 = /^[1-9]/, peg$c43 = peg$classExpectation([
          ["1", "9"]
        ], false, false), peg$c44 = /^[0-9]/, peg$c45 = peg$classExpectation([
          ["0", "9"]
        ], false, false), peg$c46 = function(r) {
          if (r.length == 1)
            return Number(r);
          return Number(r.join("").replace("%", ""));
        }, peg$c47 = "@", peg$c48 = peg$literalExpectation("@", false), peg$c49 = "TH", peg$c50 = peg$literalExpectation("TH", false), peg$c51 = /^[12]/, peg$c52 = peg$classExpectation(["1", "2"], false, false), peg$c53 = "AL", peg$c54 = peg$literalExpectation("AL", false), peg$c55 = "SP", peg$c56 = peg$literalExpectation("SP", false), peg$c57 = /^[1-3]/, peg$c58 = peg$classExpectation([
          ["1", "3"]
        ], false, false), peg$c59 = "TB", peg$c60 = peg$literalExpectation("TB", false), peg$c61 = "OH", peg$c62 = peg$literalExpectation("OH", false), peg$c63 = function(c) {
          if (!c[1])
            return "@";
          if (c[1] == "@")
            return "@@";
          return c[1].join("").replace(",", "");
        }, peg$c64 = function(c) {
          return c;
        }, peg$c65 = "+", peg$c66 = peg$literalExpectation("+", false), peg$c67 = function(c) {
          if (!c[1])
            return 1;
          if (c[1] != "+")
            return Number(c[1].join(""));
          return 2;
        }, peg$c68 = "-", peg$c69 = peg$literalExpectation("-", false), peg$c70 = function(c) {
          if (!c[1])
            return -1;
          if (c[1] != "-")
            return -Number(c[1].join(""));
          return -2;
        }, peg$c71 = "H", peg$c72 = peg$literalExpectation("H", false), peg$c73 = function(h) {
          if (h[1])
            return Number(h[1]);
          return 1;
        }, peg$c74 = ":", peg$c75 = peg$literalExpectation(":", false), peg$c76 = /^[0]/, peg$c77 = peg$classExpectation(["0"], false, false), peg$c78 = function(c) {
          return Number(c[1][0] + c[1][1].join(""));
        }, peg$c79 = function(i) {
          return Number(i.join(""));
        }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{
          line: 1,
          column: 1
        }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description, location2) {
          location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
          throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);
        }
        function error(message, location2) {
          location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
          throw peg$buildSimpleError(message, location2);
        }
        function peg$literalExpectation(text2, ignoreCase) {
          return {
            type: "literal",
            text: text2,
            ignoreCase
          };
        }
        function peg$classExpectation(parts, inverted, ignoreCase) {
          return {
            type: "class",
            parts,
            inverted,
            ignoreCase
          };
        }
        function peg$anyExpectation() {
          return {
            type: "any"
          };
        }
        function peg$endExpectation() {
          return {
            type: "end"
          };
        }
        function peg$otherExpectation(description) {
          return {
            type: "other",
            description
          };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos], p;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column
            };
            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildSimpleError(message, location2) {
          return new peg$SyntaxError(message, null, null, location2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
        }
        function peg$parsechain() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseatom();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsebranch();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsebranch();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$currPos;
              s6 = peg$parsebond();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsering();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = peg$parsebond();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsering();
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsebranch();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsebranch();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsebond();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsechain();
                    if (s7 === peg$FAILED) {
                      s7 = null;
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = [];
                      s9 = peg$parsebranch();
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$parsebranch();
                      }
                      if (s8 !== peg$FAILED) {
                        s2 = [s2, s3, s4, s5, s6, s7, s8];
                        s1 = s2;
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsebranch() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c1;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsebond();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsechain();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c3;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c4);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseatom() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseorganicsymbol();
          if (s1 === peg$FAILED) {
            s1 = peg$parsearomaticsymbol();
            if (s1 === peg$FAILED) {
              s1 = peg$parsebracketatom();
              if (s1 === peg$FAILED) {
                s1 = peg$parsewildcard();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsebond() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c7.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            if (s1 === input.charAt(peg$currPos + 1)) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                throw peg$buildSimpleError("The parser encountered a bond repetition.", peg$currPos + 1);
              }
            }
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsebracketatom() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseisotope();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c12) {
                s4 = peg$c12;
                peg$currPos += 2;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c13);
                }
              }
              if (s4 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c14) {
                  s4 = peg$c14;
                  peg$currPos += 2;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c15);
                  }
                }
                if (s4 === peg$FAILED) {
                  s4 = peg$parsearomaticsymbol();
                  if (s4 === peg$FAILED) {
                    s4 = peg$parseelementsymbol();
                    if (s4 === peg$FAILED) {
                      s4 = peg$parsewildcard();
                    }
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsechiral();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsehcount();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsecharge();
                    if (s7 === peg$FAILED) {
                      s7 = null;
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseclass();
                      if (s8 === peg$FAILED) {
                        s8 = null;
                      }
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s9 = peg$c16;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c17);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c18(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseorganicsymbol() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 66) {
            s2 = peg$c19;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 114) {
              s3 = peg$c21;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c22);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 67) {
              s2 = peg$c23;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 108) {
                s3 = peg$c25;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c26);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              if (peg$c27.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c29(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsearomaticsymbol() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c30.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c31);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsewildcard() {
          var s0, s1;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c32;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c34(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseelementsymbol() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (peg$c35.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s2 !== peg$FAILED) {
            if (peg$c37.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c38);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c39(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsering() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 37) {
            s2 = peg$c40;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c41);
            }
          }
          if (s2 !== peg$FAILED) {
            if (peg$c42.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            if (s3 !== peg$FAILED) {
              if (peg$c44.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsechiral() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 64) {
            s2 = peg$c47;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 64) {
              s3 = peg$c47;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c49) {
                s4 = peg$c49;
                peg$currPos += 2;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c50);
                }
              }
              if (s4 !== peg$FAILED) {
                if (peg$c51.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c52);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c53) {
                  s4 = peg$c53;
                  peg$currPos += 2;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c54);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c51.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c52);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c55) {
                    s4 = peg$c55;
                    peg$currPos += 2;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c56);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    if (peg$c57.test(input.charAt(peg$currPos))) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c58);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s4 = [s4, s5];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c59) {
                      s4 = peg$c59;
                      peg$currPos += 2;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c60);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      if (peg$c42.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c43);
                        }
                      }
                      if (s5 !== peg$FAILED) {
                        if (peg$c44.test(input.charAt(peg$currPos))) {
                          s6 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s6 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c45);
                          }
                        }
                        if (s6 === peg$FAILED) {
                          s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                          s4 = [s4, s5, s6];
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c61) {
                        s4 = peg$c61;
                        peg$currPos += 2;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c62);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        if (peg$c42.test(input.charAt(peg$currPos))) {
                          s5 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c43);
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          if (peg$c44.test(input.charAt(peg$currPos))) {
                            s6 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c45);
                            }
                          }
                          if (s6 === peg$FAILED) {
                            s6 = null;
                          }
                          if (s6 !== peg$FAILED) {
                            s4 = [s4, s5, s6];
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsecharge() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseposcharge();
          if (s1 === peg$FAILED) {
            s1 = peg$parsenegcharge();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseposcharge() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s2 = peg$c65;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s3 = peg$c65;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c66);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (peg$c42.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              if (s4 !== peg$FAILED) {
                if (peg$c44.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c45);
                  }
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c67(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsenegcharge() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c68;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c69);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s3 = peg$c68;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c69);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (peg$c42.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              if (s4 !== peg$FAILED) {
                if (peg$c44.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c45);
                  }
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c70(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsehcount() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 72) {
            s2 = peg$c71;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
          if (s2 !== peg$FAILED) {
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c73(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseclass() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c74;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c75);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            if (peg$c42.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              if (peg$c44.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c44.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c45);
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              if (peg$c76.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c77);
                }
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c78(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseisotope() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (peg$c42.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s2 !== peg$FAILED) {
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              if (peg$c44.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c79(s1);
          }
          s0 = s1;
          return s0;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    }();
  }
});

// node_modules/smiles-drawer/src/SvgWrapper.js
var require_SvgWrapper = __commonJS({
  "node_modules/smiles-drawer/src/SvgWrapper.js"(exports, module2) {
    var {
      getChargeText
    } = require_UtilityFunctions();
    var Line = require_Line();
    var Vector2 = require_Vector2();
    var SvgWrapper = class {
      constructor(themeManager, target, options) {
        this.svg = document.getElementById(target);
        this.opts = options;
        this.gradientId = 0;
        this.paths = [];
        this.vertices = [];
        this.gradients = [];
        this.offsetX = 0;
        this.offsetY = 0;
        this.drawingWidth = 0;
        this.drawingHeight = 0;
        this.halfBondThickness = this.opts.bondThickness / 2;
        this.themeManager = themeManager;
        this.maskElements = [];
        let mask = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        mask.setAttributeNS(null, "x", 0);
        mask.setAttributeNS(null, "y", 0);
        mask.setAttributeNS(null, "width", "100%");
        mask.setAttributeNS(null, "height", "100%");
        mask.setAttributeNS(null, "fill", "white");
        this.maskElements.push(mask);
        while (this.svg.firstChild) {
          this.svg.removeChild(this.svg.firstChild);
        }
      }
      constructSvg() {
        let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), masks = document.createElementNS("http://www.w3.org/2000/svg", "mask"), style = document.createElementNS("http://www.w3.org/2000/svg", "style"), paths = document.createElementNS("http://www.w3.org/2000/svg", "g"), vertices = document.createElementNS("http://www.w3.org/2000/svg", "g"), pathChildNodes = this.paths;
        masks.setAttributeNS(null, "id", "text-mask");
        style.appendChild(document.createTextNode(`
                .element {
                    font: ${this.opts.fontSizeLarge}pt Helvetica, Arial, sans-serif;
                    alignment-baseline: 'middle';
                }
                .sub {
                    font: ${this.opts.fontSizeSmall}pt Helvetica, Arial, sans-serif;
                }
            `));
        for (let path of pathChildNodes) {
          paths.appendChild(path);
        }
        for (let vertex of this.vertices) {
          vertices.appendChild(vertex);
        }
        for (let mask of this.maskElements) {
          masks.appendChild(mask);
        }
        for (let gradient of this.gradients) {
          defs.appendChild(gradient);
        }
        paths.setAttributeNS(null, "mask", "url(#text-mask)");
        if (this.svg) {
          this.svg.appendChild(defs);
          this.svg.appendChild(masks);
          this.svg.appendChild(style);
          this.svg.appendChild(paths);
          this.svg.appendChild(vertices);
          return this.svg;
        } else {
          let container = document.createElementNS("http://www.w3.org/2000/svg", "g");
          container.appendChild(defs);
          container.appendChild(masks);
          container.appendChild(style);
          container.appendChild(paths);
          container.appendChild(vertices);
          return container;
        }
      }
      createGradient(line) {
        let gradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), gradientUrl = `line-${this.gradientId++}`, l = line.getLeftVector(), r = line.getRightVector(), fromX = l.x + this.offsetX, fromY = l.y + this.offsetY, toX = r.x + this.offsetX, toY = r.y + this.offsetY;
        gradient.setAttributeNS(null, "id", gradientUrl);
        gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
        gradient.setAttributeNS(null, "x1", fromX);
        gradient.setAttributeNS(null, "y1", fromY);
        gradient.setAttributeNS(null, "x2", toX);
        gradient.setAttributeNS(null, "y2", toY);
        let firstStop = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        firstStop.setAttributeNS(null, "stop-color", this.themeManager.getColor(line.getLeftElement()) || this.themeManager.getColor("C"));
        firstStop.setAttributeNS(null, "offset", "20%");
        let secondStop = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        secondStop.setAttributeNS(null, "stop-color", this.themeManager.getColor(line.getRightElement() || this.themeManager.getColor("C")));
        secondStop.setAttributeNS(null, "offset", "100%");
        gradient.appendChild(firstStop);
        gradient.appendChild(secondStop);
        this.gradients.push(gradient);
        return gradientUrl;
      }
      createSubSuperScripts(text, shift) {
        let elem = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        elem.setAttributeNS(null, "baseline-shift", shift);
        elem.appendChild(document.createTextNode(text));
        elem.setAttributeNS(null, "class", "sub");
        return elem;
      }
      determineDimensions(vertices) {
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        for (var i = 0; i < vertices.length; i++) {
          if (!vertices[i].value.isDrawn) {
            continue;
          }
          let p = vertices[i].position;
          if (maxX < p.x)
            maxX = p.x;
          if (maxY < p.y)
            maxY = p.y;
          if (minX > p.x)
            minX = p.x;
          if (minY > p.y)
            minY = p.y;
        }
        let padding = this.opts.padding;
        maxX += padding;
        maxY += padding;
        minX -= padding;
        minY -= padding;
        this.drawingWidth = maxX - minX;
        this.drawingHeight = maxY - minY;
        let scaleX = this.svg.clientWidth / this.drawingWidth;
        let scaleY = this.svg.clientHeight / this.drawingHeight;
        let scale = scaleX < scaleY ? scaleX : scaleY;
        let viewBoxDim = Math.round(this.drawingWidth > this.drawingHeight ? this.drawingWidth : this.drawingHeight);
        this.svg.setAttributeNS(null, "viewBox", `0 0 ${viewBoxDim} ${viewBoxDim}`);
        this.offsetX = -minX;
        this.offsetY = -minY;
        if (scaleX < scaleY) {
          this.offsetY += this.svg.clientHeight / (2 * scale) - this.drawingHeight / 2;
        } else {
          this.offsetX += this.svg.clientWidth / (2 * scale) - this.drawingWidth / 2;
        }
      }
      drawBall(x, y, elementName) {
        let ball = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        ball.setAttributeNS(null, "cx", x + this.offsetX);
        ball.setAttributeNS(null, "cy", y + this.offsetY);
        ball.setAttributeNS(null, "r", this.opts.bondLength / 4.5);
        ball.setAttributeNS(null, "fill", this.themeManager.getColor(elementName));
        this.vertices.push(ball);
      }
      drawDashedWedge(line) {
        if (isNaN(line.from.x) || isNaN(line.from.y) || isNaN(line.to.x) || isNaN(line.to.y)) {
          return;
        }
        let offsetX = this.offsetX, offsetY = this.offsetY, l = line.getLeftVector().clone(), r = line.getRightVector().clone(), normals = Vector2.normals(l, r);
        normals[0].normalize();
        normals[1].normalize();
        let isRightChiralCenter = line.getRightChiral(), start, end;
        if (isRightChiralCenter) {
          start = r;
          end = l;
        } else {
          start = l;
          end = r;
        }
        let dir = Vector2.subtract(end, start).normalize(), length = line.getLength(), step = 1.25 / (length / (this.opts.bondThickness * 3)), changed = false;
        let gradient = this.createGradient(line);
        for (let t = 0; t < 1; t += step) {
          let to = Vector2.multiplyScalar(dir, t * length), startDash = Vector2.add(start, to), width = 1.5 * t, dashOffset = Vector2.multiplyScalar(normals[0], width);
          startDash.subtract(dashOffset);
          let endDash = startDash.clone();
          endDash.add(Vector2.multiplyScalar(dashOffset, 2));
          this.drawLine(new Line(startDash, endDash), null, gradient);
        }
      }
      drawDebugPoint(x, y, debugText = "", color = "#f00") {
        let point = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        point.setAttributeNS(null, "cx", x + this.offsetX);
        point.setAttributeNS(null, "cy", y + this.offsetY);
        point.setAttributeNS(null, "r", "2");
        point.setAttributeNS(null, "fill", "#f00");
        this.vertices.push(point);
        this.drawDebugText(x, y, debugText);
      }
      drawDebugText(x, y, text) {
        let textElem = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textElem.setAttributeNS(null, "x", x + this.offsetX);
        textElem.setAttributeNS(null, "y", y + this.offsetY);
        textElem.setAttributeNS(null, "class", "debug");
        textElem.setAttributeNS(null, "fill", "#ff0000");
        textElem.setAttributeNS(null, "style", `
                font: 5px Droid Sans, sans-serif;
            `);
        textElem.appendChild(document.createTextNode(text));
        this.vertices.push(textElem);
      }
      drawLine(line, dashed = false, gradient = null) {
        let opts = this.opts, stylesArr = [
          ["stroke-linecap", "round"],
          ["stroke-dasharray", dashed ? "5, 5" : "none"]
        ], l = line.getLeftVector(), r = line.getRightVector(), fromX = l.x + this.offsetX, fromY = l.y + this.offsetY, toX = r.x + this.offsetX, toY = r.y + this.offsetY;
        let styles = stylesArr.map((sub) => sub.join(":")).join(";"), lineElem = document.createElementNS("http://www.w3.org/2000/svg", "line");
        lineElem.setAttributeNS(null, "x1", fromX);
        lineElem.setAttributeNS(null, "y1", fromY);
        lineElem.setAttributeNS(null, "x2", toX);
        lineElem.setAttributeNS(null, "y2", toY);
        lineElem.setAttributeNS(null, "style", styles);
        this.paths.push(lineElem);
        if (gradient == null) {
          gradient = this.createGradient(line, fromX, fromY, toX, toY);
        }
        lineElem.setAttributeNS(null, "stroke", `url('#${gradient}')`);
      }
      drawPoint(x, y, elementName) {
        let ctx = this.ctx;
        let offsetX = this.offsetX;
        let offsetY = this.offsetY;
        let mask = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        mask.setAttributeNS(null, "cx", x + offsetX);
        mask.setAttributeNS(null, "cy", y + offsetY);
        mask.setAttributeNS(null, "r", "1.5");
        mask.setAttributeNS(null, "fill", "black");
        this.maskElements.push(mask);
        let point = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        point.setAttributeNS(null, "cx", x + offsetX);
        point.setAttributeNS(null, "cy", y + offsetY);
        point.setAttributeNS(null, "r", "0.75");
        point.setAttributeNS(null, "fill", this.themeManager.getColor(elementName));
        this.vertices.push(point);
      }
      drawText(x, y, elementName, hydrogens, direction, isTerminal, charge, isotope, attachedPseudoElement = {}) {
        let offsetX = this.offsetX, offsetY = this.offsetY, pos = {
          x: x + offsetX,
          y: y + offsetY
        }, textElem = document.createElementNS("http://www.w3.org/2000/svg", "text"), writingMode = "horizontal-tb", letterSpacing = "normal", textOrientation = "mixed", textDirection = "direction: ltr;", xShift = -2, yShift = 2.5;
        let mask = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        mask.setAttributeNS(null, "cx", pos.x);
        mask.setAttributeNS(null, "cy", pos.y);
        mask.setAttributeNS(null, "r", "3.5");
        mask.setAttributeNS(null, "fill", "black");
        this.maskElements.push(mask);
        if (/up|down/.test(direction) && !isTerminal) {
          writingMode = "vertical-rl";
          textOrientation = "upright";
          letterSpacing = "-1px";
        }
        if (direction === "down" && !isTerminal) {
          xShift = 0;
          yShift = -2;
        } else if (direction === "up" && !isTerminal) {
          xShift = 0.5;
        } else if (direction === "left") {
          xShift = 2;
        }
        if (direction === "left" || direction === "up" && !isTerminal) {
          textDirection = "direction: rtl; unicode-bidi: bidi-override;";
        }
        textElem.setAttributeNS(null, "x", pos.x + xShift);
        textElem.setAttributeNS(null, "y", pos.y + yShift);
        textElem.setAttributeNS(null, "class", "element");
        textElem.setAttributeNS(null, "fill", this.themeManager.getColor(elementName));
        textElem.setAttributeNS(null, "style", `
                text-anchor: start;
                writing-mode: ${writingMode};
                text-orientation: ${textOrientation};
                letter-spacing: ${letterSpacing};
                ${textDirection}
            `);
        let textNode = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        if (elementName.length > 1) {
          let textAnchor = /up|down/.test(direction) ? "middle" : "start";
          textNode.setAttributeNS(null, "style", `
                unicode-bidi: plaintext;
                writing-mode: lr-tb;
                letter-spacing: normal;
                text-anchor: ${textAnchor};
            `);
        }
        textNode.appendChild(document.createTextNode(elementName));
        textElem.appendChild(textNode);
        if (charge) {
          let chargeElem = this.createSubSuperScripts(getChargeText(charge), "super");
          textNode.appendChild(chargeElem);
        }
        let isotopeText = "0";
        if (isotope > 0) {
          let isotopeElem = this.createSubSuperScripts(isotope.toString(), "super");
          textNode.appendChild(isotopeElem);
        }
        if (charge === 1 && elementName === "N" && attachedPseudoElement.hasOwnProperty("0O") && attachedPseudoElement.hasOwnProperty("0O-1")) {
          attachedPseudoElement = {
            "0O": {
              element: "O",
              count: 2,
              hydrogenCount: 0,
              previousElement: "C",
              charge: ""
            }
          };
          charge = 0;
        }
        if (hydrogens > 0) {
          let hydrogenElem = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          hydrogenElem.setAttributeNS(null, "style", "unicode-bidi: plaintext;");
          hydrogenElem.appendChild(document.createTextNode("H"));
          textElem.appendChild(hydrogenElem);
          if (hydrogens > 1) {
            let hydrogenCountElem = this.createSubSuperScripts(hydrogens, "sub");
            hydrogenElem.appendChild(hydrogenCountElem);
          }
        }
        for (let key in attachedPseudoElement) {
          if (!attachedPseudoElement.hasOwnProperty(key)) {
            continue;
          }
          let element = attachedPseudoElement[key].element, elementCount = attachedPseudoElement[key].count, hydrogenCount = attachedPseudoElement[key].hydrogenCount, elementCharge = attachedPseudoElement[key].charge, pseudoElementElem = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          pseudoElementElem.setAttributeNS(null, "style", "unicode-bidi: plaintext;");
          pseudoElementElem.appendChild(document.createTextNode(element));
          pseudoElementElem.setAttributeNS(null, "fill", this.themeManager.getColor(element));
          if (elementCharge !== 0) {
            let elementChargeElem = this.createSubSuperScripts(getChargeText(elementCharge), "super");
            pseudoElementElem.appendChild(elementChargeElem);
          }
          if (hydrogenCount > 0) {
            let pseudoHydrogenElem = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            pseudoHydrogenElem.setAttributeNS(null, "style", "unicode-bidi: plaintext;");
            pseudoHydrogenElem.appendChild(document.createTextNode("H"));
            pseudoElementElem.appendChild(pseudoHydrogenElem);
            if (hydrogenCount > 1) {
              let hydrogenCountElem = this.createSubSuperScripts(hydrogenCount, "sub");
              pseudoHydrogenElem.appendChild(hydrogenCountElem);
            }
          }
          if (elementCount > 1) {
            let elementCountElem = this.createSubSuperScripts(elementCount, "sub");
            pseudoElementElem.appendChild(elementCountElem);
          }
          textElem.appendChild(pseudoElementElem);
        }
        this.vertices.push(textElem);
      }
      drawWedge(line) {
        let offsetX = this.offsetX, offsetY = this.offsetY, l = line.getLeftVector().clone(), r = line.getRightVector().clone();
        l.x += offsetX;
        l.y += offsetY;
        r.x += offsetX;
        r.y += offsetY;
        let normals = Vector2.normals(l, r);
        normals[0].normalize();
        normals[1].normalize();
        let isRightChiralCenter = line.getRightChiral();
        let start = l, end = r;
        if (isRightChiralCenter) {
          start = r;
          end = l;
        }
        let t = Vector2.add(start, Vector2.multiplyScalar(normals[0], this.halfBondThickness)), u = Vector2.add(end, Vector2.multiplyScalar(normals[0], 1.5 + this.halfBondThickness)), v = Vector2.add(end, Vector2.multiplyScalar(normals[1], 1.5 + this.halfBondThickness)), w = Vector2.add(start, Vector2.multiplyScalar(normals[1], this.halfBondThickness));
        let polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon"), gradient = this.createGradient(line, l.x, l.y, r.x, r.y);
        polygon.setAttributeNS(null, "points", `${t.x},${t.y} ${u.x},${u.y} ${v.x},${v.y} ${w.x},${w.y}`);
        polygon.setAttributeNS(null, "fill", `url('#${gradient}')`);
        this.paths.push(polygon);
      }
    };
    module2.exports = SvgWrapper;
  }
});

// node_modules/smiles-drawer/src/SvgDrawer.js
var require_SvgDrawer = __commonJS({
  "node_modules/smiles-drawer/src/SvgDrawer.js"(exports, module2) {
    var ArrayHelper = require_ArrayHelper();
    var Atom = require_Atom();
    var Drawer2 = require_Drawer();
    var Graph = require_Graph();
    var Line = require_Line();
    var SvgWrapper = require_SvgWrapper();
    var ThemeManager = require_ThemeManager();
    var Vector2 = require_Vector2();
    var SvgDrawer = class {
      constructor(options) {
        this.preprocessor = new Drawer2(options);
      }
      draw(data, target, themeName = "light", infoOnly = false) {
        let preprocessor = this.preprocessor;
        preprocessor.initDraw(data, themeName, infoOnly);
        if (!infoOnly) {
          this.themeManager = new ThemeManager(this.preprocessor.opts.themes, themeName);
          this.svgWrapper = new SvgWrapper(this.themeManager, target, this.preprocessor.opts);
        }
        preprocessor.processGraph();
        this.svgWrapper.determineDimensions(preprocessor.graph.vertices);
        this.drawEdges(preprocessor.opts.debug);
        this.drawVertices(preprocessor.opts.debug);
        if (preprocessor.opts.debug) {
          console.log(preprocessor.graph);
          console.log(preprocessor.rings);
          console.log(preprocessor.ringConnections);
        }
        return this.svgWrapper.constructSvg();
      }
      drawAromaticityRing(ring) {
        let ctx = this.ctx;
        let radius = MathHelper.apothemFromSideLength(this.opts.bondLength, ring.getSize());
        ctx.save();
        ctx.strokeStyle = this.getColor("C");
        ctx.lineWidth = this.opts.bondThickness;
        ctx.beginPath();
        ctx.arc(ring.center.x + this.offsetX, ring.center.y + this.offsetY, radius - this.opts.bondSpacing, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      drawEdges(debug) {
        let preprocessor = this.preprocessor, graph = preprocessor.graph, rings = preprocessor.rings, drawn = Array(this.preprocessor.graph.edges.length);
        drawn.fill(false);
        graph.traverseBF(0, (vertex) => {
          let edges = graph.getEdges(vertex.id);
          for (var i2 = 0; i2 < edges.length; i2++) {
            let edgeId = edges[i2];
            if (!drawn[edgeId]) {
              drawn[edgeId] = true;
              this.drawEdge(edgeId, debug);
            }
          }
        });
        if (!this.bridgedRing) {
          for (var i = 0; i < rings.length; i++) {
            let ring = rings[i];
            if (preprocessor.isRingAromatic(ring)) {
              this.drawAromaticityRing(ring);
            }
          }
        }
      }
      drawEdge(edgeId, debug) {
        let preprocessor = this.preprocessor, opts = preprocessor.opts, svgWrapper = this.svgWrapper, edge = preprocessor.graph.edges[edgeId], vertexA = preprocessor.graph.vertices[edge.sourceId], vertexB = preprocessor.graph.vertices[edge.targetId], elementA = vertexA.value.element, elementB = vertexB.value.element;
        if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && preprocessor.opts.atomVisualization === "default") {
          return;
        }
        let a = vertexA.position, b = vertexB.position, normals = preprocessor.getEdgeNormals(edge), sides = ArrayHelper.clone(normals);
        sides[0].multiplyScalar(10).add(a);
        sides[1].multiplyScalar(10).add(a);
        if (edge.bondType === "=" || preprocessor.getRingbondType(vertexA, vertexB) === "=" || edge.isPartOfAromaticRing && preprocessor.bridgedRing) {
          let inRing = preprocessor.areVerticesInSameRing(vertexA, vertexB);
          let s = preprocessor.chooseSide(vertexA, vertexB, sides);
          if (inRing) {
            let lcr = preprocessor.getLargestOrAromaticCommonRing(vertexA, vertexB);
            let center = lcr.center;
            normals[0].multiplyScalar(opts.bondSpacing);
            normals[1].multiplyScalar(opts.bondSpacing);
            let line = null;
            if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {
              line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            } else {
              line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            }
            line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);
            if (edge.isPartOfAromaticRing) {
              svgWrapper.drawLine(line, true);
            } else {
              svgWrapper.drawLine(line);
            }
            svgWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else if (edge.center || vertexA.isTerminal() && vertexB.isTerminal() || (s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1)) {
            this.multiplyNormals(normals, opts.halfBondSpacing);
            let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB), lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            svgWrapper.drawLine(lineA);
            svgWrapper.drawLine(lineB);
          } else if (s.sideCount[0] > s.sideCount[1] || s.totalSideCount[0] > s.totalSideCount[1]) {
            this.multiplyNormals(normals, opts.bondSpacing);
            let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);
            svgWrapper.drawLine(line);
            svgWrapper.drawLine(new Line(a, b, elementA, elementB));
          } else if (s.sideCount[0] < s.sideCount[1] || s.totalSideCount[0] <= s.totalSideCount[1]) {
            this.multiplyNormals(normals, opts.bondSpacing);
            let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);
            svgWrapper.drawLine(line);
            svgWrapper.drawLine(new Line(a, b, elementA, elementB));
          }
        } else if (edge.bondType === "#") {
          normals[0].multiplyScalar(opts.bondSpacing / 1.5);
          normals[1].multiplyScalar(opts.bondSpacing / 1.5);
          let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
          let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
          svgWrapper.drawLine(lineA);
          svgWrapper.drawLine(lineB);
          svgWrapper.drawLine(new Line(a, b, elementA, elementB));
        } else if (edge.bondType === ".") {
        } else {
          let isChiralCenterA = vertexA.value.isStereoCenter;
          let isChiralCenterB = vertexB.value.isStereoCenter;
          if (edge.wedge === "up") {
            svgWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
          } else if (edge.wedge === "down") {
            svgWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
          } else {
            svgWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
          }
        }
        if (debug) {
          let midpoint = Vector2.midpoint(a, b);
          svgWrapper.drawDebugText(midpoint.x, midpoint.y, "e: " + edgeId);
        }
      }
      drawVertices(debug) {
        let preprocessor = this.preprocessor, opts = preprocessor.opts, graph = preprocessor.graph, rings = preprocessor.rings, svgWrapper = this.svgWrapper;
        var i = graph.vertices.length;
        for (var i = 0; i < graph.vertices.length; i++) {
          let vertex = graph.vertices[i];
          let atom = vertex.value;
          let charge = 0;
          let isotope = 0;
          let bondCount = vertex.value.bondCount;
          let element = atom.element;
          let hydrogens = Atom.maxBonds[element] - bondCount;
          let dir = vertex.getTextDirection(graph.vertices);
          let isTerminal = opts.terminalCarbons || element !== "C" || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;
          let isCarbon = atom.element === "C";
          if (atom.element === "N" && atom.isPartOfAromaticRing) {
            hydrogens = 0;
          }
          if (atom.bracket) {
            hydrogens = atom.bracket.hcount;
            charge = atom.bracket.charge;
            isotope = atom.bracket.isotope;
          }
          if (opts.atomVisualization === "allballs") {
            svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);
          } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements) || graph.vertices.length === 1) {
            if (opts.atomVisualization === "default") {
              svgWrapper.drawText(vertex.position.x, vertex.position.y, element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());
            } else if (opts.atomVisualization === "balls") {
              svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);
            }
          } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {
            let a = graph.vertices[vertex.neighbours[0]].position;
            let b = graph.vertices[vertex.neighbours[1]].position;
            let angle = Vector2.threePointangle(vertex.position, a, b);
            if (Math.abs(Math.PI - angle) < 0.1) {
              svgWrapper.drawPoint(vertex.position.x, vertex.position.y, element);
            }
          }
          if (debug) {
            let value = "v: " + vertex.id + " " + ArrayHelper.print(atom.ringbonds);
            svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);
          } else {
            svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, vertex.value.chirality);
          }
        }
        if (opts.debug) {
          for (var i = 0; i < rings.length; i++) {
            let center = rings[i].center;
            svgWrapper.drawDebugPoint(center.x, center.y, "r: " + rings[i].id);
          }
        }
      }
      getTotalOverlapScore() {
        return this.preprocessor.getTotalOverlapScore();
      }
      getMolecularFormula() {
        return this.preprocessor.getMolecularFormula();
      }
      multiplyNormals(normals, spacing) {
        normals[0].multiplyScalar(spacing);
        normals[1].multiplyScalar(spacing);
      }
    };
    module2.exports = SvgDrawer;
  }
});

// node_modules/smiles-drawer/app.js
var require_app = __commonJS({
  "node_modules/smiles-drawer/app.js"(exports, module2) {
    var Drawer2 = require_Drawer();
    var Parser = require_Parser();
    var SvgDrawer = require_SvgDrawer();
    var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    var SmilesDrawer2 = {
      Version: "1.0.0"
    };
    SmilesDrawer2.Drawer = Drawer2;
    SmilesDrawer2.Parser = Parser;
    SmilesDrawer2.SvgDrawer = SvgDrawer;
    SmilesDrawer2.clean = function(smiles) {
      return smiles.replace(/[^A-Za-z0-9@\.\+\-\?!\(\)\[\]\{\}/\\=#\$:\*]/g, "");
    };
    SmilesDrawer2.apply = function(options, selector = "canvas[data-smiles]", themeName = "light", onError = null) {
      let smilesDrawer = new Drawer2(options);
      let elements = document.querySelectorAll(selector);
      for (var i = 0; i < elements.length; i++) {
        let element = elements[i];
        SmilesDrawer2.parse(element.getAttribute("data-smiles"), function(tree) {
          smilesDrawer.draw(tree, element, themeName, false);
        }, function(err) {
          if (onError) {
            onError(err);
          }
        });
      }
    };
    SmilesDrawer2.parse = function(smiles, successCallback, errorCallback) {
      try {
        if (successCallback) {
          successCallback(Parser.parse(smiles));
        }
      } catch (err) {
        if (errorCallback) {
          errorCallback(err);
        }
      }
    };
    if (canUseDOM) {
      window.SmilesDrawer = SmilesDrawer2;
    }
    if (!Array.prototype.fill) {
      Object.defineProperty(Array.prototype, "fill", {
        value: function(value) {
          if (this == null) {
            throw new TypeError("this is null or not defined");
          }
          var O = Object(this);
          var len = O.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k < final) {
            O[k] = value;
            k++;
          }
          return O;
        }
      });
    }
    module2.exports = SmilesDrawer2;
  }
});

// main.ts
__export(exports, {
  default: () => ObsidianMoleculeRenderer
});
var import_obsidian2 = __toModule(require("obsidian"));

// obsidian-settings/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var parseBoolean = (value) => {
  return value == "yes" || value == "true";
};
var parseObject = (value, typ) => {
  if (typ == "string") {
    return value;
  }
  if (typ == "boolean") {
    return parseBoolean(value);
  }
  if (typ == "number") {
    return parseFloat(value);
  }
};
function display(obj, DEFAULT_SETTINGS2, name) {
  const { containerEl } = obj;
  containerEl.empty();
  containerEl.createEl("h2", { text: "Settings for " + name });
  let keyvals = Object.entries(DEFAULT_SETTINGS2);
  for (let keyval of keyvals) {
    let setting = new import_obsidian.Setting(containerEl).setName(keyval[1].name).setDesc(keyval[1].desc);
    if (typeof keyval[1].value == "boolean") {
      setting.addToggle((toggle) => toggle.setValue(obj.plugin.settings[keyval[0]].value).onChange((bool) => {
        obj.plugin.settings[keyval[0]].value = bool;
        obj.plugin.saveSettings();
      }));
    } else {
      setting.addText((text) => text.setPlaceholder(String(keyval[1].value)).setValue(String(obj.plugin.settings[keyval[0]].value)).onChange((value) => {
        obj.plugin.settings[keyval[0]].value = parseObject(value, typeof keyval[1].value);
        obj.plugin.saveSettings();
      }));
    }
  }
}
function loadSettings(obj, DEFAULT_SETTINGS2) {
  obj.settings = DEFAULT_SETTINGS2;
  obj.loadData().then((data) => {
    if (data) {
      let items = Object.entries(data);
      items.forEach((item) => {
        obj.settings[item[0]].value = item[1];
      });
    }
  });
}
function saveSettings(obj, DEFAULT_SETTINGS2) {
  return __async(this, null, function* () {
    let saveData = {};
    Object.entries(obj.settings).forEach((i) => {
      saveData[i[0]] = i[1].value;
    });
    yield obj.saveData(saveData);
  });
}

// main.ts
var SmilesDrawer = __toModule(require_app());
var NAME = "Obsidian Molecule Renderer";
var CODEBLOCK = "molecule";
var SMILES = "smiles";
var DEFAULT_SETTINGS = {
  a: { value: "a", name: "a", desc: "a" }
};
var ObsidianMoleculeRenderer = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new ObsidianMoleculeRendererSettings(this.app, this));
      let colors = {};
      let updateColor = () => __async(this, null, function* () {
        let s = getComputedStyle(document.body);
        colors.C = s.getPropertyValue("--text-normal");
        colors.O = s.getPropertyValue("--text-accent");
        colors.N = s.getPropertyValue("--text-selection").split(",").slice(0, 3).join(",") + ")";
        colors.F = s.getPropertyValue("--interactive-success");
        colors.CL = colors.F;
        colors.BR = s.getPropertyValue("--text-error");
        colors.I = s.getPropertyValue("--interactive-accent");
        colors.P = colors.BR;
        colors.S = s.getPropertyValue("--text-highlight-bg").split(",").slice(0, 3).join(",") + ")";
        colors.B = s.getPropertyValue("--text-error-hover");
        colors.SI = colors.B;
        colors.H = s.getPropertyValue("--text-muted");
        colors.BACKGROUND = s.getPropertyValue("--background-primary");
      });
      updateColor();
      let renderSMILES = (smiles, el) => __async(this, null, function* () {
        console.log(colors);
        let canvas = el.createEl("canvas");
        canvas.style.width = "100%";
        let size = Math.round(parseFloat(getComputedStyle(canvas).width));
        let smilesDrawer = new SmilesDrawer.Drawer({
          width: size,
          height: size,
          themes: {
            light: colors
          }
        });
        SmilesDrawer.parse(smiles, (tree) => __async(this, null, function* () {
          yield smilesDrawer.draw(tree, canvas);
        }), (err) => {
          console.log(err);
        });
      });
      this.registerMarkdownCodeBlockProcessor(CODEBLOCK, (src, el, ctx) => __async(this, null, function* () {
        let req = JSON.parse(yield (0, import_obsidian2.request)({ url: "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/" + src + "/property/IsomericSMILES/JSON" }));
        if ("Fault" in req) {
          let heading = el.createEl("h1");
          heading.innerText = "Chemical Not found";
          heading = el.createEl("h2");
          heading.innerText = "Similar Chemicals include:";
          let jsonGet = JSON.parse(yield (0, import_obsidian2.request)({ url: "https://pubchem.ncbi.nlm.nih.gov/rest/autocomplete/compound/" + src })).dictionary_terms;
          if (jsonGet && "compound" in jsonGet) {
            let suggestions = jsonGet.compound;
            let list = el.createEl("ol");
            for (let i of suggestions) {
              let item = list.createEl("li");
              item.innerText = i.toLowerCase();
            }
          }
        } else {
          let smiles = req.PropertyTable.Properties[0].IsomericSMILES;
          console.log(smiles);
          smiles = "C(CC(=O)O)[C@@H](C(=O)O)N";
          yield renderSMILES(smiles, el);
        }
      }));
      this.registerMarkdownCodeBlockProcessor(SMILES, (src, el, ctx) => __async(this, null, function* () {
        setTimeout(() => __async(this, null, function* () {
          let smiles = src.replace("\n", "");
          smiles = "C(CC(=O)O)[C@@H](C(=O)O)N";
          console.log(smiles);
          yield renderSMILES(smiles, el);
        }), 1e3);
      }));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      loadSettings(this, DEFAULT_SETTINGS);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield saveSettings(this, DEFAULT_SETTINGS);
    });
  }
};
var ObsidianMoleculeRendererSettings = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    display(this, DEFAULT_SETTINGS, NAME);
  }
};
